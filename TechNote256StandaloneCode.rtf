{\rtf1\mac\deff2 {\fonttbl{\f2\froman New York;}{\f3\fswiss Geneva;}{\f4\fmodern Monaco;}{\f13\fnil Zapf Dingbats;}{\f16\fnil Palatino;}{\f20\froman Times;}{\f21\fswiss Helvetica;}{\f22\fmodern Courier;}{\f23\ftech Symbol;}{\f1109\fnil Trebuchet MS;}{\f2001\fnil Arial;}{\f2002\fnil Charcoal;}{\f2003\fnil Capitals;}{\f2004\fnil Sand;}{\f2005\fnil Courier New;}{\f2006\fnil Techno;}{\f2010\fnil Times New Roman;}{\f2013\fnil Hoefler Text;}{\f2018\fnil Hoefler Text Ornaments;}{\f2039\fnil Impact;}{\f2040\fnil Skia;}{\f2305\fnil Textile;}{\f2307\fnil Gadget;}{\f2311\fnil Apple Chancery;}{\f3725\fnil CommercialPi BT;}{\f4513\fnil Comic Sans MS;}{\f7102\fnil Andale Mono;}{\f7203\fnil Verdana;}{\f9840\fnil Espy Sans;}{\f9842\fnil Espy Sans Bold;}{\f12077\fnil Arial Black;}{\f12171\fnil Georgia;}{\f12813\fnil Futura Bk BT;}{\f12906\fnil Bodoni Bd BT;}{\f12935\fnil ZapfHumnst Ult BT;}{\f14213\fnil Webdings;}{\f14809\fnil eWorld Tight;}{\f15311\fnil BernhardMod BT;}{\f15377\fnil Impress BT;}{\f15475\fnil Kuenst480 BT;}{\f15476\fnil Kuenst480 Blk BT;}{\f15488\fnil Bodoni BT;}{\f15610\fnil ZapfHumnst BT;}{\f15981\fnil Futura Md BT;}{\f16383\fnil Chicago;}}{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}{\stylesheet{\f20 \sbasedon222\snext0 Normal;}}{\info{\title TechNote256StandaloneCode.rtf}{\author Shere-Ling Kraus-Yao}}\margl1440\margr2160\widowctrl\ftnbj \sectd \linemod0\linex0\cols1\endnhere {\header \pard\plain \qj\li180\ri-1520\tx9720\tx10159 \f20 {\par }}{\footer \pard\plain \qj\li180\ri-900\tx9000\tx9539 \f20 {\fs20 _____________________________________________________________________________________________\par \par #256:  Stand-Alone Code, }{\i\fs20 ad nauseam}{\fs20 \tab of 32}{\fs20 \chpgn }{\fs20 \par }}\pard\plain \li180\ri-900 \f20 {{\pict\macpict\picw468\pich85\picscaled 013900070007005c01ec1101a00082a0008ca0008ca10096000605000000025ca1009a00080006000000510000a0009801000a00070007005c01ec2c000800140554696d65730300140d00182b0e1d0a4d6163696e746f73680da00099a1009a0008ffee000000510000a000982a180f546563686e6963616c204e6f746573a00099a00097a10096000605000000025ca1009a0008fffc0000006c0000a000980d00122bf11f1b446576656c6f70657220546563686e6963616c20537570706f7274a00099a00097070002000220003f0009003f01d9a0008da0008ca10096000605000000025ca1009a0008ffef0000001b0000a000980d003028003701b201f0a00099a00097a10096000605000000025ca1009a0008fffe000000060000a000980d0009292201a8a00099a00097a0008da0008da00083ff}}\par \pard \qc\li180\ri-900 {\par }\pard \qj\fi-1080\li1260\ri-900 {\b\fs36 #256:\tab Stand-Alone Code, }{\b\i\fs36 ad nauseam\par }{\par }\pard \qj\fi-1440\li1620\ri-900\tx7920\tx9539 {Written by:\tab Craig Prouse\tab August 1990\par Inspired by:\tab Keith Rollin & Keithen Hayenga\tab October 1989\par \par }\pard \qj\li180\ri-900 {This Technical Note discusses many of the issues related to stand-alone code modules.  This Note is by no means a completely original work, as the author borrows freely from the work of Keith Rollin, Mark Baumwell, and Jim Friedlander.\par }{\b Changes since October 1989:}{  Completely rewritten to broaden the discussion of stand-alone code modules and include a greater scope of examples.  Incorporates Technical Notes #110, MPW: Writing Stand-Alone Code and #145, Debugger FKEY.\par ______________________________________________________________________________\par \par \par }{\b\fs28 How to Recognize a Stand-Alone Code When You See One\par }{\par }{\b What Stand-Alone Code Looks Like to the Naked Eye\par }{\par Stand-alone code is program code which does not enjoy the full status of an application.  A stand-alone code module exists as a single Macintosh resource and consists almost entirely of microprocessor-executable object code, and perhaps also some header data and other constants used by the executable portion of the module.  Code-type resources are most easily identifiable in the ResEdit 2.0 resource picker.  Most of these closely-related resources are indicated by an icon containing a stylized segment of assembly-language source code.\par \par }\pard \li180\ri-900 {{\pict\macpict\picw186\pich89\picscaled 063f00e900d6014201901101a0008201000a0000000002d0024098001a00a600bc00ff018400a600c300ff017d00e900d6014201900000060001eaffff00080001eb0002018000080001eb0002018000080001eb00020180001105017effefffc0f4000607ffeffefd8000150b0100802000003c00060007c0f800040822018000170b017e802fffc0620006000660fa000607ffe822fd80001b19010080200000603c3e3c0663c3878ccd9c3c38000008220180001b06017e802fffc060fe660f0666664cccce32666407ffe822fd80001b0601008020000060fe660f07c6670ccccc306670000008220180001b19017e802fffc06066667e0667e38ccccc307e3807ffefe2fd80001b0c01008020000060666660066601fecc0930601c000008020180001b0c017e802fffc062666662066624fecc0932624c07ffe802fd80001b190100802000003c3c3e3c0663c38787cc1c3c38000008020180001105017effefffc0f4000607ffeffefd8000080001eb0002018000080001eb0002018000080001eb0002018000070001eaff018000090001ec000380018000090001ec000381018000090001ec000382818000090001ec000384418000090001ec000388218000090001ec000390118000090001ec0003a0098000090001ec0003f83d8000090001ec000388218000090001ec000388218000090001ec000388218000090001ec00038fe18000090001ec0003800180000f06010004525104c0f20003800180000f0601000275510a40f20003ffff80000f0601000e55510e40f20003800180000f0601000e52212a40f20003800180000d0001fd000040f10003800180000d0001f700003ff7000380018000140601000017709120fd00014080f80003800180001b0601000014512a90fe0003ffbf7fe0fe00081fffc00000800180001b0d01000053613a9000000100a14030fe00083000600000800180001b0d0100002750a92000000200e1c050fe00082fffa0000080018000160001f9000004fe000090fe00082800a0000080018000160001f9000007feff0010fe00082800a00000800180001b0d010000357190e000000800000110fe000829e4a00000800180001b0d010000475150200000080fff8110fe00082904a00000800180001b0d010000456150400000080fff8110fe00082904a00000800180001b0d010000354192e000000809248110fe000829c4a00000800180001a0001fd000004fe00040809248110fe00082904a0000080018000160001f90004080fff8110fe00082904a00000800180001b05010000757080fe00040809248110fe00082904a00000800180001b05010000676040fe00040809248110fe00082800a00000800180001b050100005741c0fe0004080fff8110fe00082800a00000800180001b050100006571c0fe00040809248110fe00082fffa0000080018000160001f900040809248110fe0008300060000080018000160001f90004080fff8110fe00081fffc000008001800015040100006770fd00040809248110f900038001800015040100005240fd00040809248110f90003ffff800015040100006220fd0004080fff8120f900038001800015040100005270fd00040800000140f9000380018000110001f900040800000180f900038fe180000f0001f9000007fefff8000388218000090001ec000388218000090001ec000388218000090001ec0003f83d8000090001ec0003a0098000090001ec000390118000090001ec000388218000190501000071ce3cfd0002e3c8bcfd00087a2f4400008441800019050100008a2920fd00029228a2fd000842484400008281800019050100008228a0fd00028a28a2fd000842882800008101800019050100008228b8fd00028bc53cfd0008730e1000008001800019050100008228a0fd00028a8528fd00084288100000ffff800019050100008a2920fd0002924224fd0008424810000080018000190501000071ce3cfd0002e22222fd0008422f10000080018000090001ec00039fc18000090001ec000390418000090001ec0003907d8000090001ec000390458000090001ec000390458000090001ec000390458000090001ec00039fc58000090001ec000384058000090001ec000384058000090001ec000384058000090001ec000387fd8000090001ec000380018000070001eaff018000070000eaff018000a00083ff}}\par \pard \qc\li180\ri-900 {\par }{\b Figure 1\endash ResEdit 2.0 Icons Signifying Code-Type Resources\par }\pard \qj\li180\ri-900 {\par Although }{\f22 'CODE'}{ resources are not stand-alone code modules (they are segments of a larger application), they are similar because they contain executable code and so they have the same code-type icon.  Driver resources are a special case of stand-alone code resources, and they have a different icon in the ResEdit picker, reminiscent of the Finder icon for a desk accessory suitcase, because the code of a desk accessory is stored as a }{\f22 'DRVR'}{ resource.  The icon for an }{\f22 'FKEY'}{ is also a bit different, resembling a function key, naturally.\par \par }\page {Table 1 is a fairly extensive list of the currently-defined code-type resources.  Many are of interest primarily at a system software level; those stand-alone code resources most commonly created by application-level programmers are noted in boldface.  Of course, developers are always free to define new resource types for custom stand-alone modules.  }{\f22 'CUST'}{ is commonly used, as in some of the examples at the end of the discussion.\par \par }\pard \qc\li540\ri-540\tx1800\tx3060\tx4320\tx5580\tx6840\tx8100\tx9179 {\f22 ADBS\tab adev\tab CACH\tab }{\b\f22 CDEF\tab cdev}{\f22 \tab CODE\tab dcmd\par }{\b\f22 DRVR\tab }{\f22 FKEY\tab FMTR\tab }{\b\f22 INIT}{\f22 \tab itl2\tab itl4\tab }{\b\f22 LDEF\par }{\f22 MBDF\tab }{\b\f22 MDEF\tab }{\f22 mntr\tab PACK\tab PDEF\tab PTCH\tab ptch\par rdev\tab ROvr\tab RSSC\tab snth\tab }{\b\f22 WDEF}{\f22 \tab }{\b\f22 XCMD}{\f22 \tab }{\b\f22 XFCN\par }{\par }{\b Table 1\endash Assorted Code Resource Types\par }\pard \qj\li180\ri-900 {\par The most common use of stand-alone code is to supplement the standard features provided by the Macintosh Toolbox and operating system.  Most of the resource types listed in Table 1 define custom windows, controls, menus, lists, and responses to user input.  In this respect, they are slaves to particular Toolbox managers or packages and very often contained within the resource fork of an owner application.  Other examples of stand-alone code are more useful as application extensions like HyperCard }{\f22 'XCMD'}{ and }{\f22 'XFCN'}{ extensions.\par \par }{\f22 'DRVR'}{, }{\f22 'INIT'}{, and }{\f22 'cdev'}{ resources are more autonomous examples of stand-alone code.  These allow programmers to write code which may be executed automatically when the system starts up and code which adds special features to the operating system or provides control of special-purpose peripherals and system functions.  The temptation here is to perform functions generally reserved for full-blown applications, such as use of QuickDraw.  For a number of reasons, this is a non-trivial endeavor, and is the subject of much of this discussion.\par \par }{\b How Applications Are Special\par }{\par Macintosh applications can be almost any size, limited mainly by disk space and RAM size.  The actual program code is generally divided up into a number of segments, each less than 32K in size so the amount of memory required to execute a program may be less than the size of the program itself.  The Segment Loader, documented in }{\i Inside Macintosh}{, Volume II, controls the loading and unloading of segments.  It ensures that the necessary segments of an application are read into the application heap when needed and allows temporarily unneeded sections to be purged, making room for others.\par \par All of this activity occurs in and depends upon a somewhat mysterious construction called an }{\f22 A5 }{world.  It is so called because the }{\f22 A5}{ register of the microprocessor points indirectly to several key data structures used by the Segment Loader and the application itself.  Most Macintosh programmers are at least vaguely aware of the significance of }{\f22 A5}{ in the Macintosh environment.  Many even know that it is a handy pointer to the application and QuickDraw global variables, or at least points in the right general direction.  Less widely known is how an }{\f22 A5}{ world is constructed, and more to the point, how to build one from scratch if necessary.\par \par This may become necessary because higher-level language compilers like MPW Pascal and C automatically generate }{\f22 A5}{-relative addressing modes to refer to global variables, including QuickDraw globals.  The linker then resolves the actual offsets.  For example, the ubiquitous\par \par }\pard \li180\ri-900 {\f22\fs18     InitGraf(@thePort);        \{initialize QuickDraw\}\par }\pard \qj\li180\ri-900 {\par compiles into something equivalent to the following:\par \par }\pard \li180\ri-900 {\f22\fs18     PEA   thePort(A5),-(SP)    ; push a pointer to QuickDraw's thePort variable\par     _InitGraf                  ; invoke _InitGraf trap to initialize QuickDraw\par }\page \pard \qj\li180\ri-900 {\par Before this is executable, the linker must determine exactly what offset represents }{\f22 thePort.}{  With this value, it patches the object code and creates the code found in the final application.  The reader may infer that an application depends on someone else to set up }{\f22 A5}{ with a meaningful value before program execution begins.  This is true, and understanding how this process normally occurs for an application is of paramount importance when writing stand-alone code which needs application-like functionality.  Briefly, the Segment Loader allocates space for an }{\f22 A5}{ world for each application as part of its launch process.  Library code is automatically linked to the front of every application, and this sets up }{\f22 A5}{ to point to the global variable space.  The application code begins executing only after all of this preliminary setup is complete.\par \par }\pard \li180\ri-900 {{\pict\macpict\picw407\pich324\picscaled 0ece00070007014b019e1101a00082a0008c01000a00070007014b019e34000e00f4011301840aaa55aa55aa55aa553400b500f000be01803000b500f000bf01810a88228822882288223400be00f000c701803000be00f000c801810a77dd77dd77dd77dd3400c700f000d001803000c700f000d101810affffffffffffffff3400ac00f000b501803000ac00f000b601810a00000000000000003400a300f000ac01803000a300f000ad018134005200f00091018030005200f0009201810affffffffffffffff340043005a011b00bd300043005a011c00be0a00000000000000003400400057011800ba3000400057011900bb3000640057009b00bb070002000230003f0056006500bb34002f00f100520180070001000130002e00f000530181a0008ca000a00affffffffffffffff84008400d9006400e7006e00d90069006a7fff00da006800697fff00dc006a006b7fff00dd006700687fff00df006b006c7fff00e0006600677fff00e20069006a006c006d7fff00e30065006600680069006a006b7fff00e400670068006b006c7fff00e500660067006c006e7fff00e600640066006d006e7fff00e7006400657fff7fff07000000002200d90069050e23fbfb23fb052305f2a000a10700010001220118006900caa0008da0008ca000a084007800720065007e006d0072006500667fff007300660067006c006d7fff00740065006600670068006b006c7fff007500680069006a006b006c006d7fff00760069006a7fff0077006600677fff0078006b006c7fff007a006700687fff007b006a006b7fff007d006800697fff007e0069006a7fff7fff070000000022007f0069fbf22305052305fb23fb0ea000a1070001000122006400690012a0008da1009600060100000002dca1009a0008fffe000000180000a000982c000a001607436f75726965720300160d00092b0b9d094170706c4c696d6974a00099a00097a1009600060100000002dca1009a0008fffd000000160000a000982c000c00150948656c76657469636103001504010d000a280056007607476c6f62616c73a00099a00097a1009600060100000002dca1009a0008fffd0000000e0000a00098040028007c007405537461636ba00099a00097a1009600060100000002dca1009a0008fffd0000000e0000a000982b03560448656170a00099a00097a0008ca000a0840074004b00410054004e004b004200447fff004c00420043004400477fff004d004300440047004a7fff004e00440045004a004d7fff004f004d004e7fff005000440045004b004e7fff0051004300440048004b7fff005200420043004500487fff0053004100457fff0054004100427fff7fff070000000022004f004ef2fb23050523fb05230efba000a1070001000122004f0045f700a0008da1009600060100000002dca1009a0008fffd000000080000a00098030016280053002d024135a00099a00097a0008ca000a0840074004e00da005700e7004e00db00dd7fff004f00db00dc00dd00e07fff005000dc00dd00e000e37fff005100dd00de00e300e67fff005200e600e77fff005300dd00de00e400e77fff005400dc00dd00e100e47fff005500db00dc00de00e17fff005600da00de7fff005700da00db7fff7fff070000000022005200e7f2fb23050523fb05230efba000a1070001000122005200def700a0008da1009600060100000002dca1009a0008fffd000000080000a000982b9803024135a00099a000970a000000000000000034009100f000a3018030009100f000a40181a1009600060100000002dca1009a0008fffd000000170000a000982b5f4807746865506f7274a00099a00097a1009600060100000002dca1009a0008fffe000000190000a000980300150d000928008800830a67726f777320646f776ea00099a00097a1009600060100000002dca1009a0008fffe000000140000a000982b02580867726f7773207570a00099a00097220049019b005aa0008ca000a00affffffffffffffff840074009f018a00a80197009f019401967fff00a001910194019501967fff00a1018e0191019401957fff00a2018b018e019301947fff00a3018a018b7fff00a4018a018d019301947fff00a5018d0190019401957fff00a601900193019501967fff00a7019301977fff00a8019601977fff7fff07000000002200a301890e0523fbfb2305fb23f205a000a107000100012200a3019bf700a0008d220049019be5000a000000000000000034000a00f0002e018030000a00f0002f0181a1009600060100000002dca1009a0008fffd0000001c0000a000980d000a280021011e0a4a756d70205461626c65a00099a00097a1009600060100000002dca1009a00080003000000220000a000980300160d000928005e01170e617070476c6f62616c566172310da00099a1009a0008fff8000000220000a000982a0b0d617070476c6f62616c56617232a00099a00097a1009600060100005a02dca1009a0008fffd0000000c0000a0009801000a00000000000000000300150d000a2b191205a520a5caa501000a00070007014b019e900002006c013200800142006c013700800142006c013700800142000100700070007000000000000000700070007000000000000000000000000000000070007000700000a00099a000973400d000f000eb01803000d000f000ec01813400eb00f000fd01803000eb00f000fe0181a1009600060100000002dca1009a0008fffe0000001b0000a000980300160d00092800f701200a73637265656e42697473a00099a000973400fd00f0010f01803000fd00f001100181a1009600060100000002dca1009a0008fffe000000160000a000982b05120872616e6453656564a00099a00097a1009600060100000002dca1009a0008fffe000000160000a0009828011b000e084170706c5a6f6e65a00099a00097a0008ca000a00affffffffffffffff84007400960041009f004e0096004200447fff009700420043004400477fff0098004300440047004a7fff009900440045004a004d7fff009a004d004e7fff009b00440045004b004e7fff009c004300440048004b7fff009d00420043004500487fff009e004100457fff009f004100427fff7fff070000000022009a004ef2fb23050523fb05230efba000a1070001000122009a0045f700a0008da0008ca000a084007401140041011d004e0114004200447fff011500420043004400477fff0116004300440047004a7fff011700440045004a004d7fff0118004d004e7fff011900440045004b004e7fff011a004300440048004b7fff011b00420043004500487fff011c004100457fff011d004100427fff7fff0700000000220118004ef2fb23050523fb05230efba000a107000100012201180045f700a0008da1009600060100000002dca1009a0008fffd000000410000a000980300150d000a28004d00f91c706f696e74657220746f20517569636b4472617720676c6f62616c73a00099a00097a1009600060100000002dca1009a0008fffd000000390000a0009828003b010118d24170706c69636174696f6e20506172616d6574657273d3a00099a00097070002000230000900ef0110018107000100012000d000f000d001772000ac00f000ac0177a1009600060100000002dca1009a0008fffe0000000e0000a000980300160d00092b36a6056172726f77a00099a000979000060000000000120028000000000012002400d7011500e901390001000000000e3c000200000002000300000e3c000380000f070003c0000f000003e00002b40003f0000f0a0003f80000020003fc0002a70003e000099100036000094000023000000500003000003b00001800000000001800000e00000000000e000000000f08000000000ead2000c700f000c701772000b500f000b501772000be00f000be017722004000ba36caa0008c22004000ba06fa22003300c706fa22002700d307f922001a00e007f922000d00ed03fda0008d20006400ba010f00f0a0008c22006400ba030922007500bf030922008600c5030922009700ca03092200a900d002082200ba00d503082200cb00db02092200dc00e003092200ed00e503092200fe00eb0209a0008da1009600060100000002dca1009a0008fffe000000220000a0009828008b01170d617070476c6f62616c5661724ea00099a0009720004000f000400180a0008c22004000f0000022004000f4000022004000f8000022004000fc0000220040010000002200400104000022004001080000220040010c0000220040011000002200400114000022004001180000220040011c0000220040012000002200400124000022004001280000220040012c0000220040013000002200400134000022004001380000220040013c0000220040014000002200400144000022004001480000220040014c0000220040015000002200400154000022004001580000220040015c0000220040016000002200400164000022004001680000220040016c0000220040017000002200400174000022004001780000220040017c0000a0008da0008c0a00000000000000003400ac012400c8014b07000200023000ab012300ca014d3400b0012600c40148a1009600060200000002dca1009a00080003000000060000a000980300152b1a2c0351440da00099a1009a0008fff8000000110000a000982800c20126085061747465726e73a00099a00097a0008da1009600060100000002dca1009a0008fffe000000160000a0009828007b01500a28736565206e6f746529a00099a00097a1009600060500000002dca1009a000800090000009f0000a0009828012f004f4b4e6f74653a204170706c69636174696f6e20676c6f62616c73206d6179206170706561722061626f7665206f722062656c6f772074686520517569636b4472617720676c6f62616c732e20a00099a1009a0008fffe0000009f0000a000982a0b4e54686973206973206c696e6b65722d646570656e64656e742e2057686174277320696d706f7274616e7420697320746861742073657061726174656c792d6c696e6b65642065787465726e616c20a00099a1009a0008fff30000009f0000a000982a0b406d6f64756c65732063616e2075736520413520746f206c6f6361746520616e206170706c69636174696f6e277320517569636b4472617720676c6f62616c732ea00099a00097a0008da00083ff}}\par \pard \qc\li180\ri-900 {\par }{\b Figure 2\endash A Hitchhiker\rquote s Guide to the A5 World\par }\pard \qj\li180\ri-900 {\par }{\b How Stand-Alone Code Is Different\par }{\par Stand-alone code, unlike an application, is never launched.  It is simply loaded then executed and possesses no }{\f22 A5}{ world of its own.  Stand-alone code therefore cannot easily define global variables.  No space is allocated for globals and }{\f22 A5}{ either belongs to a real application or is completely meaningless.  References to global variables defined by the module usually succeed without even a warning from the linker, but also generally overwrite globals defined by the current application.  References to global variables defined in the MPW libraries, like QuickDraw globals, generate fatal link errors.\par \par }\pard \li180\ri-900 \page {\f22\fs18     \par Link -t INIT -c '????' -rt INIT=128 -ra =resLocked -m PLAYZOO \'b6\par         SampleINIT.p.o \'b6\par         -o SampleINIT\par     ### Link: Error: Undefined entry, name: (Error 28) "thePort"\par       Referenced from: PLAYZOO in file: SampleINIT.p.o\par     ### Link: Errors prevented normal completion.\par     ### MPW Shell - Execution of SampleINIT.makeout terminated.\par     ### MPW Shell - Execution of BuildProgram terminated.\par }\pard \qj\li180\ri-900 {\par That\rquote s not very helpful and not very much fun.  So what if a stand-alone code resource needs to use QuickDraw or its associated globals like }{\f22 screenBits}{?  What if a stand-alone module needs to call some \ldblquote innocuous\rdblquote  routine in the Macintosh Toolbox which implicitly assumes the existence of a valid }{\f22 A5}{ world?  }{\f22 _Unique1ID}{, which calls the QuickDraw }{\f22 _Random}{ trap, falls into this category, for instance.  An }{\f22 'XCMD'}{ might be able to \ldblquote borrow\rdblquote  HyperCard\rquote s globals, but an }{\f22 'INIT'}{ has no such alternative; it may need to have its own }{\f22 A5}{ world.\par \par There are a couple more considerations.  Stand-alone code resources are not applications and are not managed by the Segment Loader, so they cannot be segmented into multiple resources like applications.  Stand-alone code resources are self-contained modules and are usually less than 32K in size.  As popular belief would have it, code resources }{\b cannot}{ be more than 32K in size.  This is not necessarily true, and although some linkers, especially older ones, enforce the limit all the same, the absolute limitation is that the original Motorola MC68000 microprocessor is not capable of expressing relative offsets which span more than 32K.\par \par A code segment for a 68000-based Macintosh may be any reasonable length, so long as no relative offsets exceed 32K.  There are ways to get around this limit even on 68000-based machines, while the MC68020 and later members of the 680x0 family have the ability to specify 32-bit offsets, dissolving the 32K barrier completely as long as the compiler is agreeable.  To remain compatible with 68000-based machines, however, and to maintain manageable-sized code segments the 32K \ldblquote limit\rdblquote  is a good rule of thumb.  If a stand-alone code module gets much larger than this, it is often because it\rquote s trying to do too much.  Remember that stand-alone code should only perform simple and specific tasks.\par \par }{\b Writing Your First Stand-Alone Module\par }{\par Each type of stand-alone code has its own idiosyncrasies.  It is difficult to say which type is the easiest to construct.  It is best to address each major type individually, but a simple }{\f22 'INIT'}{ may be the best place to start.  Most programmers are pretty familiar with the concept of what an }{\f22 'INIT'}{ is and how it is used, and its autonomy is a big plus\emdash it is not necessary to write and debug a separate piece of code or a HyperCard stack in which to test the stand-alone module.  (This would be necessary for a }{\f22 'CDEF'}{ or an }{\f22 'XCMD'}{, for example.)  Stand-alone code is often written in assembly language, but high-level languages usually serve just as well.  This first example is written in MPW Pascal, in keeping with the precedent set by }{\i Inside Macintosh}{.\par \par SampleINIT is a very simple }{\f22 'INIT'}{ which plays each of the sounds (resources of type }{\f22 'snd'}{) in the System file while the Macintosh boots.  It\rquote s kind of fun, not too obnoxious, and also not particularly robust.  All }{\f22 'snd' }{resources should be unlocked, purgeable, Format 1 sounds like the four default system sounds.  Also be sure to name this file SampleINIT.p to work with the SampleINIT.make file which follows.  The main subroutine is }{\f22 PlayZoo}{, in honor of the monkey and dogcow sounds in the author\rquote s System file.\par \par }\pard \li180\ri-900 \page {\f22\fs18     \par UNIT SampleINIT;    \{Pascal stand-alone code is written as a UNIT\}\par \par     INTERFACE\par \par       USES\par         Types, Resources, Sound;\par \par       \{VAR\par         cannot define any globals...well, not yet anyway\}\par \par       PROCEDURE PlayZoo;\par \par     IMPLEMENTATION\par \par       PROCEDURE PlayZoo;\par       VAR\par         numSnds, i : INTEGER;\par         theSnd : Handle;\par         playStatus : OSErr;\par       BEGIN\par         numSnds := CountResources('snd ');\par         FOR i := 1 TO numSnds DO BEGIN\par           theSnd := GetIndResource('snd ',i);\par           IF theSnd <> NIL THEN\par             playStatus := SndPlay(NIL,theSnd,FALSE);\par           END;\par       END;\par \par     END.\par }\pard \qj\li180\ri-900 {\par Following is the file SampleINIT.make to control the build process:\par \par }\pard \li180\ri-900 {\f22\fs18     #   File:       SampleINIT.make\par     #   Target:     SampleINIT\par     #   Sources:    SampleINIT.p\par \par     SampleINIT \'c4\'c4 SampleINIT.make SampleINIT.p.o\par         Link -t INIT -c '????' -rt INIT=128 -ra =resLocked -m PLAYZOO \'b6\par             SampleINIT.p.o \'b6\par             -o SampleINIT\par \par     SampleINIT.p.o \'c4 SampleINIT.make SampleINIT.p\par         Pascal SampleINIT.p\par }\pard \qj\li180\ri-900 {\par That\rquote s all there is to it, but even in such a simple example as this, there are a number of extremely important points to highlight.  By understanding every nuance of this example, one moves a long way toward understanding everything there is to know about stand-alone code.\par \par Consider first the form of the }{\f22 'INIT'}{ code itself.  It is defined as a }{\f22 UNIT}{ rather than a }{\f22 PROGRAM}{.  This is important, because Pascal programs are applications and require the Segment Loader, preinitialization of }{\f22 A5}{, and all the things which make an application special.  A Pascal unit, like a stand-alone code resource, is simply a collection of subroutines.  A similar assembly-language }{\f22 'INIT'}{ would define and export a }{\f22 PROC}{.  In C, this particular }{\f22 'INIT'}{ would be a single function in a source file with no }{\f22 main()}{ function.\par \par Pascal programmers may recognize that a unit allows the definition of global variables (as between the }{\f22 USES}{ and }{\f22 PROCEDURE}{ clauses in the }{\f22 INTERFACE}{ section previously documented).  Typically, when a unit\rquote s object code is linked with a host application, the linker allocates storage for these globals along with the application globals and resolves all necessary }{\f22 A5}{ references.  Stand-alone code modules are never linked with an application, however, and the linker has no way to resolve these references.  This makes the linker very unhappy.  The easiest way to make the linker happy is to follow the example and define no globals. If globals are really necessary, and they may well be, read on.\par \par Next examine how SampleINIT is linked.  To be recognized as a startup document, a \ldblquote system extension\rdblquote  (as an }{\f22 'INIT'}{ is called in System 7.0 parlance) must have the file type \ldblquote INIT\rdblquote .  The options }{\f22 -rt }{and }{\f22 -ra }{respectively specify that the code resource is of type }{\f22 'INIT'}{ (ID=128), and that the resource itself is locked.  This is a very important idiosyncrasy of the }{\f22 'INIT'}{ because it is not automatically locked when loaded by the system and might otherwise attempt to move during execution.  Hint:  this would be very bad.\par \par Finally, }{\f22 PlayZoo}{ is specified as the main entry point by the }{\f22 -m }{option.  When written in Pascal, the entry point of a module is the first compiled instruction.  C is a little pickier and demands the main entry point option to override the default entry point (which performs run-time initialization for applications).  It is important to remember that the linker does not move the entry point specified by }{\f22 -m}{ to the front of the object file\emdash that is the programmer\rquote s responsibility.  Specification of this option primarily helps the linker remove dead, unused code from the final object module.  In short, don\rquote t leave home without it.  Note that the linker is case sensitive with respect to identifiers, while the Pascal compiler converts them to all uppercase.  It is necessary therefore (in this example) to specify the name of the entry point to the linker in all uppercase characters.  If }{\f22 PlayZoo}{ were written in C, which is also case-sensitive, the identifier would be passed to the linker exactly as it appeared in the source code.\par \par For additional examples of stand-alone code, refer to the end of this Note.  There are currently a few examples of types of stand-alone code, some of which illustrate the advanced topics discussed in the following sections.\par \par The next area to investigate is how to get around the restrictions on globals in stand-alone code.  The first and simplest solution easily conforms to all compatibility guidelines, and that is to avoid using globals altogether.  There often comes a time, however, when the use of a global seems unavoidable.  The global variable requirements of stand-alone code segments vary, naturally, and there are a number of possible scenarios.  Some involve creating an }{\f22 A5}{ world and others do not.  It\rquote s best to start with the simplest cases, which do not.\par \par \par }{\b\fs28 Oh, I Have Slipped the Surly Bonds of the Linker...\par }{\par }{\b ...And Have Hung Like a Leach on My Host Application\par }{\par Often a stand-alone code segment needs the QuickDraw globals of the current application, for whom it is performing a service.  A control definition function (}{\f22 'CDEF'}{) is an example.  Its drawing operations assume a properly-initialized QuickDraw world, which is graciously provided by the application.  Most QuickDraw calls are supported and no special effort is required.  One limitation, however, is that explicit references to QuickDraw globals like }{\f22 thePort}{ and }{\f22 screenBits}{ are not allowed.  The linker cannot resolve the offsets to these variables because it does not process a }{\f22 'CDEF'}{ (or any other stand-alone module) along with a particular application.  Fortunately the solution is simple, if not entirely straightforward.\par \par Since the structure of the QuickDraw global data is known, as is its location relative to }{\f22 A5}{, stand-alone code executing as a servant to an application can reference any desired QuickDraw global indirectly.  The following code is an example of how a stand-alone unit can make local copies of all the application QuickDraw globals.  It uses }{\f22 A5}{ to locate the variables indirectly, rather than making explicit symbolic references which the linker is not capable of resolving.  Figure 2, presented earlier, may be helpful in understanding how this code works.\par }\pard \li180\ri-900 \page {\f22\fs18     \par UNIT GetQDGlobs;\par \par INTERFACE\par \par       USES\par         Types, QuickDraw, OSUtils;\par   \par       TYPE\par         QDVarRecPtr  =  ^QDVarRec;\par         QDVarRec  =  RECORD\par                   randSeed   : Longint;\par                   screenBits : BitMap;\par                   arrow      : Cursor;\par                   dkGray     : Pattern;\par                   ltGray     : Pattern;\par                   gray       : Pattern;\par                   black      : Pattern;\par                   white      : Pattern;\par                   thePort    : GrafPtr;\par                 END;\par \par       PROCEDURE GetMyQDVars (VAR qdVars: QDVarRec);\par \par     IMPLEMENTATION\par \par       PROCEDURE GetMyQDVars (VAR qdVars: QDVarRec);\par       TYPE\par         LongPtr = ^Longint;\par       BEGIN\par         \{ Algorithm:\par           1.  Get current value of A5 with SetCurrentA5.\par           2.  Dereference to get address of thePort.\par           3.  Perform arithmetic to determine address of randSeed.\par           4.  By assignment, copy the QD globals into a local data structure. \}\par         qdVars := QDVarRecPtr(LongPtr(SetCurrentA5)^ - (SizeOf(QDVarRec)-SizeOf(thePort)))^;\par       END;\par \par     END.\par }\pard \qj\li180\ri-900 {\par }{\b Extensible Applications\par }{\par Some applications are intended to be extensible and provide special support for stand-alone code segments.  ResEdit for instance, uses }{\f22 'RSSC'}{ code resources to provide support for custom resource pickers and editors.  If a graphical editor is needed to edit a custom resource type, such as an 8 }{\fs20 x}{ 64-pixel icon, separately compiled and linked extension code can be pasted directly into the application\rquote s resource fork.  ResEdit defines interfaces through which it communicates with these resources.  In many cases, this degree of support and message passing can preempt the need to declare global variables at all.  The ResEdit interfaces are part of the official ResEdit package available from APDA.  The MacsBug }{\f22 'dcmd'}{ is another instance of extension code with support for globals built in.  A }{\f22 'dcmd'}{ specifies in its header how much space it needs for global variables and MacsBug makes room for them.\par \par HyperCard provides high-level support for its }{\f22 'XCMD'}{ and }{\f22 'XFCN'}{ extension resources.  Callback routines like }{\f22 SetGlobal}{ and }{\f22 GetGlobal}{ provide extension code with a convenient mechanism for defining variables which are global in scope, yet without requiring the deadly }{\f22 A5}{-relative references normally associated with global variables.  The HyperCard interfaces are included with MPW and are called HyperXCmd.p in the Pascal world, or HyperXCmd.h for C programmers.\par \par In cases where an application provides special support for extensions, the extension writer should take advantage of this support as much as possible.  Things can get complicated quickly when no support for globals is provided or when built-in support is not used, and there\rquote s really no reason to be a masochist.  The }{\f22 A5}{-world techniques described later in this Note usually are not necessary and should be considered extraordinary.  Also, when writing an application, it is probably worth considering whether extensibility is useful or desirable.  With the move toward object-oriented programming and reusable code, demand for extension module support is growing.  Support for extension modules can rarely be tacked on as an afterthought, and it is worth looking at how ResEdit, HyperCard, and Apple File Exchange support modular code when considering similar features.  Foresight and planning are indispensable.\par \par }{\b Calling Stand-Alone Code from Pascal\par }{\par Before moving on it may be helpful to look at how one extensible application calls stand-alone code, using HyperCard as an example.  The first thing to do is establish some standard means of communication.  HyperCard uses a clearly-defined parameter block, as defined in HyperXCmd.p.\par \par }\pard \li180\ri-900 {\f22\fs18     XCmdPtr = ^XCmdBlock;\par     XCmdBlock = RECORD\par       paramCount:  INTEGER;\par       params:      ARRAY [1..16] OF Handle;\par       returnValue: Handle;\par       passFlag:    BOOLEAN;\par       entryPoint:  ProcPtr;    \{to call back to HyperCard\}\par       request:     INTEGER;\par       result:      INTEGER;\par       inArgs:      ARRAY [1..8] OF LONGINT;\par       outArgs:     ARRAY [1..4] OF LONGINT;\par       END;\par }\pard \qj\li180\ri-900 {\par An }{\f22 'XCMD'}{ procedure, like an }{\f22 'INIT'}{, is written, compiled, and linked as a separate unit.  Its prototype may be imagined something like this:\par \par }\pard \li180\ri-900 {\f22\fs18     PROCEDURE MyXCMD (pb: XCMDPtr);\par       EXTERNAL;\par }\pard \qj\li180\ri-900 {\par Since }{\f22 MyXCMD}{ is not linked with HyperCard, however, the example declaration does not appear in the HyperCard source code.  The prototype only defines how the external module expects to receive its parameters.  The host application, HyperCard, is responsible for loading the module and implementing the proper calling conventions.\par \par When calling an }{\f22 'XCMD'}{, HyperCard first loads the resource into memory and locks it down.  It then fills in the parameter block and invokes the }{\f22 'XCMD'}{.  Notice that the extension module is loaded by its resource name.  This is common for extensible applications, since it avoids resource numbering conflicts.  Since HyperCard is written in Pascal, the sequence might look something like this.\par \par }\pard \li180\ri-900 {\f22\fs18     HLock(theHandle);\par     WITH paramBlock DO\par       BEGIN\par         \{ fill it in \}\par       END;\par     CallXCMD(@paramBlock, theHandle);\par     HUnlock(theHandle);\par }\pard \qj\li180\ri-900 {\par This also looks a little unwieldy.  To fully understand a high-level calling sequence for stand-alone code, a working knowledge of parameter passing conventions and the ability to read code at the assembly-language level is very helpful.  Some amount of glue code is almost always required, as illustrated by }{\f22 CallXCMD}{.  After Pascal places a pointer to the parameter block and a handle to the }{\f22 'XCMD'}{ on the stack, it executes some assembly-language glue represented by three inline opcodes.  The glue code finds the }{\f22 'XCMD'}{ in memory and jumps to it using the handle on the stack.  To accomplish this, it pulls the handle off of the stack, dereferences it to obtain a pointer to the }{\f22 'XCMD'}{ and performs a }{\f22 JSR}{ to the indicated address.  The pointer to the parameter block is left on the stack for the }{\f22 'XCMD'}{.\par \par }\pard \li180\ri-900 {\f22\fs18     PROCEDURE CallXCMD (pb: XCMDPtr; xcmd: Handle);\par       INLINE $205F,    \{ MOVEA.L  (A7)+,A0         pop handle off stack        \}\par              $2050,    \{ MOVEA.L  (A0),A0   dereference to get address of XCMD \}\par              $4E90;    \{ JSR      (A0)        call XCMD, leaving pb on stack   \}\par }\pard \qj\li180\ri-900 {\par Figure 3 illustrates the state of the }{\f22 A5}{ world at four critical phases of the }{\f22 'XCMD'}{ calling sequence.  Boldface indicates approximately where the program counter is pointing, or what code is executing at that moment.  The easiest way to read the diagram is to look for features which change from one state to the next.  Note in the last state the }{\f22 'XCMD'}{ knows how to find its parameter block because the stack pointer (}{\f22 A7}{) initially points to the return address and a pointer to the parameter block is located four bytes above that.  If the }{\f22 'XCMD'}{ is written in a high-level language according to the procedure prototype }{\f22 MyXCMD}{, as shown above, this procedure is handled automatically by the compiler.\par \par The process is essentially the same when calling stand-alone code from assembly language, but it is not so unnatural.  The assembly-language programmer never has to leave his element and generally has a better low-level view of where certain data structures reside and how to access them efficiently.  Since the entry point of the stand-alone module can be determined directly, there is no exact parallel to the }{\f22 CallXCMD}{ procedure, and it is not necessary to push a copy of the resource handle on the stack as an intermediate step.\par \par }\pard \li180\ri-900 {{\pict\macpict\picw464\pich306\picscaled 113500070007013901d71101a00082a0008c01000a00070007013901d70aaa55aa55aa55aa5534000a0014010f005c070002000230000900130111005e0a000000000000000034001400150025005c070001000130001300140026005d34002500140037005c30002500140038005d3400400014005b005c3000400014005c005da10096000601000000023ba1009a0008fffe000000090000a000982c000a001607436f75726965720300160d00092b311f03683d3fa00099a00097a10096000601000000023ba1009a0008fffe0000001b0000a0009828003100200a706172616d426c6f636ba00099a00097340088001400ac005c300088001400ad005d3400e2001400eb005c3000e2001400ec005d3400d0001400d9005c3000d0001400da005d3400f400140106005c3000f400140107005d3401060014010f005c30010600140110005d07000200022200870013480022003f001348000aaa55aa55aa55aa5534000b008a010f00d13000090088011100d30a0000000000000000340014008a002500d107000100013000130089002600d23400250089003700d13000250089003800d23400400089005b00d13000400089005c00d2a10096000601000000023ba1009a0008fffe000000040000a0009828001f00ab0168a00099a00097a10096000601000000023ba1009a0008fffe0000001b0000a0009828003100950a706172616d426c6f636ba00099a00097340088008900ac00d1300088008900ad00d23400b5008900d000d13000b5008900d100d23400e2008900eb00d13000e2008900ec00d23400d0008900d900d13000d0008900da00d23400f40089010600d13000f40089010700d23401060089010f00d13001060089011000d207000200022200870088480022003f00884800a10096000602000000023ba1009a00080009000000210000a000982c000c00150948656c76657469636103001528011d001913496e697469616c205374617465207769746820a00099a1009a0008fffe0000002b0000a00098280128000f14706172616d426c6f636b20616e64206820617320a00099a1009a0008fff3000000200000a000982b0b0b10676c6f62616c207661726961626c6573a00099a00097a10096000602000000023ba1009a00080009000000390000a0009828011d007618476574314e616d65645265736f75726365206c6f61647320a00099a1009a0008fffe0000002b0000a000982b0e0b152758434d4427207265736f7572636520696e746f20a00099a1009a0008fff3000000210000a000982b0a0b106170706c69636174696f6e2068656170a00099a000970aaa55aa55aa55aa5534000b00ff010f014630000900fd011101480a000000000000000034001400ff00250146070001000130001300fe0026014734002500fe0037014630002500fe0038014734004000fe005b014630004000fe005c0147a10096000601000000023ba1009a0008fffe000000040000a0009803001628001f01200168a00099a00097a10096000601000000023ba1009a0008fffe0000001b0000a00098280031010a0a706172616d426c6f636ba00099a0009734008800fe00ac014630008800fe00ad01473400b500fe00d001463000b500fe00d101473400e200fe00eb01463000e200fe00ec01473400d000fe00d901463000d000fe00da01473400f400fe010601463000f400fe0107014734010600fe010f014630010600fe0110014734006d00fe007f014630006d00fe00800147070002000222008700fd480022003f00fd480034005c00ff006d0146070001000130005b00fe006e0147a10096000602000000023ba1009a00080009000000310000a0009803001528011d00f31543616c6c58434d442070757368657320736f6d6520a00099a1009a0008fffe000000320000a0009828012800f21b7374756666206f6e2074686520737461636b20666f722074686520a00099a1009a0008fff3000000130000a000982b1f0b09676c756520636f6465a00099a0009722001c0089dc00a0008ca000a00affffffffffffffff8400540102007b010a00880102007b007d7fff0103007d00807fff0104008000847fff0105008400877fff0106008700887fff0107008500887fff0108008100857fff0109007e00817fff010a007b007e7fff7fff07000000002201060089f2042300fc2300fc230e04a000a1070001000122010600651600a0008d2200fd0089e5002300d3a0008ca000a084005400cc007b00d4008800cc007b007d7fff00cd007d00807fff00ce008000847fff00cf008400877fff00d0008700887fff00d1008500887fff00d2008100857fff00d3007e00817fff00d4007b007e7fff7fff07000000002200d00089f2042300fc2300fc230e04a000a107000100012200d0006e0d00a0008da10096000601000000023ba1009a0008fffd000000180000a000980d000a28010000970a6d617374657220707472a00099a00097a0008ca000a0840054010200f0010a00fd010200f000f27fff010300f200f57fff010400f500f97fff010500f900fc7fff010600fc00fd7fff010700fa00fd7fff010800f600fa7fff010900f300f67fff010a00f000f37fff7fff070000000022010600fef2042300fc2300fc230e04a000a1070001000122010600da1600a0008da0008ca000a0840054003300f0003b00fd003300f000f27fff003400f200f57fff003500f500f97fff003600f900fc7fff003700fc00fd7fff003800fa00fd7fff003900f600fa7fff003a00f300f67fff003b00f000f37fff7fff070000000022003700fef2042300fc2300fc230e04a000a1070001000122003700e30d00a0008da10096000601000000023ba1009a0008fffd000000180000a0009829750a6d617374657220707472a00099a00097a10096000602000000023ba1009a0008fffd0000000e0000a000982800c6009f0458434d44a00099a00097a10096000602000000023ba1009a0008fffd0000000e0000a0009829750458434d44a00099a00097a10096000602000000023ba1009a00080003000000200000a000980401280097001d0c4170706c69636174696f6e20a00099a1009a0008fff7000000110000a000982b0f0c04434f4445a00099a00097a10096000602000000023ba1009a00080003000000200000a0009828009700920c4170706c69636174696f6e20a00099a1009a0008fff7000000110000a000982b0f0c04434f4445a00099a00097a10096000602000000023ba1009a00080003000000200000a0009828009701070c4170706c69636174696f6e20a00099a1009a0008fff7000000110000a000982b0f0c04434f4445a00099a0009722006400fee50022003700e3002da0008ca000a0840054007200dc007a00e8007200e700e87fff007300e400e77fff007400e000e47fff007500dd00e07fff007600dc00dd7fff007700dc00df7fff007800df00e37fff007900e300e67fff007a00e600e87fff7fff070000000022007600da0efc23000423000423f2fca000a1070001000122007600feea00a0008d20001c00da010600daa10096000601000000023ba1009a0008fffe000000140000a0009804000d0009280079011009636f7079206f662068a00099a00097a10096000601000000023ba1009a0008fffe000000120000a0009828006701120970747220746f207062a00099a00097a10096000601000000023ba1009a0008fffd0000000d0000a000980d000a280051002d05737461636ba00099a000970aaa55aa55aa55aa5534000a0173010f01bb07000200023000090172011101bd0a00000000000000003400140174002501bb07000100013000130173002601bc3400250173003701bb3000250173003801bc3400400173005b01bb3000400173005c01bca10096000601000000023ba1009a0008fffe000000040000a000980300160d000928001f01950168a00099a00097a10096000601000000023ba1009a0008fffe0000001b0000a00098280031017f0a706172616d426c6f636ba00099a00097340088017300ac01bb300088017300ad01bc3400b5017300d001bb3000b5017300d101bc3400e2017300eb01bb3000e2017300ec01bc3400d0017300d901bb3000d0017300da01bc3400f40173010601bb3000f40173010701bc3401060173010f01bb3001060173011001bc34006d0173007f01bb30006d0173008001bc07000200022200870172480022003f0172480034005c0174006d01bb070001000130005b0173006e01bca0008ca000a00affffffffffffffff84005400960165009e01720096016501677fff00970167016a7fff0098016a016e7fff0099016e01717fff009a017101727fff009b016f01727fff009c016b016f7fff009d0168016b7fff009e016501687fff7fff070000000022009a0173f2042300fc2300fc230e04a000a1070001000122009a01580d00a0008da0008ca000a084005400330165003b01720033016501677fff00340167016a7fff0035016a016e7fff0036016e01717fff0037017101727fff0038016f01727fff0039016b016f7fff003a0168016b7fff003b016501687fff7fff07000000002200370173f2042300fc2300fc230e04a000a1070001000122003701580d00a0008da10096000601000000023ba1009a0008fffd000000180000a000980300150d000a2b02cf0a6d617374657220707472a00099a00097a10096000602000000023ba1009a0008fffd000000100000a0009804012800c601890458434d44a00099a00097a10096000602000000023ba1009a000800030000001a0000a000980400280097017f0c4170706c69636174696f6e20a00099a1009a0008fff70000000f0000a000982b0b0c04434f4445a00099a000972200640173e5002200760173e500230024a10096000601000000023ba1009a0008fffe0000001f0000a000980d0009280079017a0e72657475726e2061646472657373a00099a00097a10096000601000000023ba1009a0008fffe000000120000a0009828006701870970747220746f207062a00099a000972200370158002da10096000602000000023ba1009a00080009000000360000a0009828011d016319476c756520636f64652072656d6f7665732068616e646c6520a00099a1009a0008fffe000000380000a0009828012801611b66726f6d20737461636b20616e6420646f6573204a535220746f20a00099a1009a0008fff3000000330000a000982b050b196164647265737320696e206d617374657220706f696e746572a00099a00097a10096000601000000023ba1009a0008fffd0000000d0000a000980d000a28005100a205737461636ba00099a00097a10096000601000000023ba1009a0008fffd0000000d0000a00098297505737461636ba00099a00097a10096000601000000023ba1009a0008fffd0000000d0000a00098297505737461636ba00099a0009720001c0065010600652200fd0173e5002300d3a0008ca000a084005400cc016500d4017200cc016501677fff00cd0167016a7fff00ce016a016e7fff00cf016e01717fff00d0017101727fff00d1016f01727fff00d2016b016f7fff00d30168016b7fff00d4016501687fff7fff07000000002200d00173f2042300fc2300fc230e04a000a107000100012200d001580d00a0008d2200fd00fee5002300d3a0008ca000a084005400cc00f000d400fd00cc00f000f27fff00cd00f200f57fff00ce00f500f97fff00cf00f900fc7fff00d000fc00fd7fff00d100fa00fd7fff00d200f600fa7fff00d300f300f67fff00d400f000f37fff7fff07000000002200d000fef2042300fc2300fc230e04a000a107000100012200d000e30d00a0008d22001c00fedc0022001c0173dc00210106014fa0008ca000a084005401020165010a01720102016501677fff01030167016a7fff0104016a016e7fff0105016e01717fff0106017101727fff0107016f01727fff0108016b016f7fff01090168016b7fff010a016501687fff7fff07000000002201060173f2042300fc2300fc230e04a000a10700010001220106014f1600a0008da0008da00083ff}}\par \pard \qc\li180\ri-900 {\par }{\b Figure 3\endash Calling an 'XCMD' from Pascal\par }\pard \qj\li180\ri-900 {\par Interestingly enough, the }{\f22 CallXCMD}{ procedure can be easily modified to call almost any stand-alone module whose entry point is at the beginning of the code resource.  To determine the proper calling interface for a particular code module, simply duplicate the function prototype of the module and add a handle at the end of the argument list.  The inline glue does not have to change at all.  This works equally well for Pascal procedures or functions, and for any number of arguments including }{\f22 VAR}{ parameters.\par \par \par }{\b\fs28 Doing the A5 Road Trip\par }{\par There comes a time and place where construction of an }{\f22 A5}{ world is a \ldblquote necessary\rdblquote  evil.  Usually it\rquote s not necessary at all, but sometimes the world really needs just one more Orwellian security }{\f22 'INIT' }{to present a dialog at startup.  DTS discourages such things, but they happen.  Although there is nothing fundamentally or philosophically wrong with constructing a custom }{\f22 A5}{ world, doing so can create significant technical hassles, and unfortunately, globals make possible a number of user interface atrocities.  Generally a different solution, if available, results in simpler and more maintainable code, and reduces the likelihood that your code will go the way of the dinosaur and the passenger pigeon.  Furthermore, to make the process of constructing an }{\f22 A5}{ world as straightforward as possible, yet consistent with normal applications, extensive use is made of two undocumented routines in the MPW run-time libraries.  The dangers here are obvious.  There are accepted uses, nonetheless.  External modules may need to create some global storage or hold data which persists across multiple calls to a routine in the module.  All uses shall henceforth be considered fair game, for as it is written in Clarus\rquote  memoirs:\par \par }\pard \qc\li180\ri-900 {\i Yea, and if It will be done, even in spite,\par Then lend Thine hand to the masses,\par Lest It be done incorrectly or woefully worse\par By those not versed the the ways of the Dogcow.\par }\pard \qj\li180\ri-900 {\par }{\b Who\rquote s Got the Map?\par }{\par The ensuing discussion on how to construct an }{\f22 A5}{ world is geared primarily to programmers using MPW.  There are a couple of reasons for this.  First, looking back, the stated problem originated with an error generated by the MPW linker.  Other development systems may handle this situation differently and often offer different solutions.  Symantec products, for instance, offer }{\f22 A4}{-relative globals and avoid the globals conflict from the outset.  Secondly, this document would resemble a Russian novel if it addressed all the permutations of potential solutions for each development system.  MPW Pascal is the }{\i de facto}{ standard Macintosh programming environment for illustrative and educational purposes.  It may not be fair, but at least it\rquote s consistent.\par \par As already described, there are basically three reasons why stand-alone code might need to reserve space for its own global variables.  Consider the following three scenarios as a basis, but understand that various arbitrary combinations are also possible:\par \par }\pard \qj\fi-360\li900\ri-180 {\bullet \tab A stand-alone module consists of two functions.  There is one main entry point and one function calls another function in the process of calculating its final result.  Instead of passing a formal parameter to the subordinate function, the programmer chooses to pass a global.\par \par \bullet \tab A stand-alone module consists of one function.  The module is loaded into memory once and invoked multiple times by the host application.  The module requires its own private storage to persist across multiple invocations.\par \par }\page {\bullet \tab A complex }{\f22 'INIT'}{ uses QuickDraw, or a }{\f22 'cdev'}{ is complex enough to require an application-like set of globals to accomplish its self-contained task.  A module may need to access data in a Toolbox callback (like a dialog hook) where the interface is fixed, for instance.\par }\pard \qj\li180\ri-900 {\par Each of the demonstration units is a working example.  There is source code at the end of the discussion for simple applications which can play host to these modules and demonstrate how a complete product fits together.\par \par The first instance is relatively easy to implement.  When the module is executed, it creates an }{\f22 A5}{ world, does its job, and then tears down the }{\f22 A5}{ world, making sure to restore the host application\rquote s world.  Such a module may look something like the following example.  Pay special attention to the items in boldface.  These are specific to the use of globals in stand-alone code.\par \par }{\b LazyPass.p\par }{\par }\pard \li180\ri-900 {\f22\fs18     UNIT LazyPass;\par \par     \{ This is a stand-alone module which implements the function \}\par     \{ of determining a circle's area from its circumference.     \}\par \par     INTERFACE\par \par       USES\par         Types, }{\b\f22\fs18 SAGlobals}{\f22\fs18 ;\par \par       FUNCTION CircleArea (circumference: Real) : Real;\par \par     IMPLEMENTATION\par \par       \{ Define a variable global to all \}\par       \{ of the routines in this unit.   \}\par       }{\b\f22\fs18 VAR radius : Real;\par }{\f22\fs18 \par       FUNCTION RadiusSquared : Real;\par       FORWARD;\par \par       \{ CircleArea is defined first so that the entry point is \}\par       \{ conveniently located at the beginning of the module.   \}\par \par       FUNCTION CircleArea (circumference: Real) : Real;\par       VAR\par         }{\b\f22\fs18 A5Ref: A5RefType;\par }{\f22\fs18         }{\b\f22\fs18 oldA5: Longint;\par }{\f22\fs18       BEGIN\par         }{\b\f22\fs18 oldA5 := OpenA5World(A5Ref);\par }{\f22\fs18           radius := circumference / (2.0 * Pi);\par           CircleArea := Pi * RadiusSquared;\par         }{\b\f22\fs18 CloseA5World(oldA5, A5Ref);\par }{\f22\fs18       END;\par \par       FUNCTION RadiusSquared : Real;\par       BEGIN\par         RadiusSquared := radius * radius;\par       END;\par \par     END.\par }\pard \qj\li180\ri-900 {\par }\page {\b LazyPass.make\par }{\par This is the makefile for the }{\f22 LazyPass}{ module.\par \par }\pard \li180\ri-900 {\f22\fs18     #   File:       LazyPass.make\par     #   Target:     LazyPass\par     #   Sources:    LazyPass.p\par \par     OBJECTS = LazyPass.p.o\par \par     LazyPass \'c4\'c4 LazyPass.make \{OBJECTS\}\par       Link -w -t '????' -c '????' -rt CUST=128 -m CIRCLEAREA -sg LazyPass \'b6\par         \{OBJECTS\} \'b6\par         "\{Libraries\}"Runtime.o \'b6\par         "\{Libraries\}"Interface.o \'b6\par         "\{PLibraries\}"SANELib.o \'b6\par         "\{PLibraries\}"PasLib.o \'b6\par         "\{MyLibraries\}"SAGlobals.o \'b6\par         -o LazyPass\par     LazyPass.p.o \'c4 LazyPass.make LazyPass.p\par        Pascal -i "\{MyInterfaces\}" LazyPass.p\par }\pard \qj\li180\ri-900 {\par The second instance is a little trickier and requires the cooperation of the host application.  The module needs the ability to pass a reference to its global variable storage (}{\f22 A5}{ world) back to the application so that it can be easily restored the next time the module is invoked.  In addition, there must be some way to notify the module the first time and the last time it is to be called.  This kind of module is exemplified by the following:\par \par }{\b Persist.p\par }{\par }\pard \li180\ri-900 {\f22\fs18     UNIT Persist;\par \par     \{ This is a stand-alone module which maintains a running total \}\par     \{ of the squares of the parameters it receives. This requires  \}\par     \{ the cooperation of a host application. The host must use     \}\par     \{ messages to tell the module when to initialize and when to   \}\par     \{ tear down. The host also must maintain a handle to the       \}\par     \{ module's A5 world between invocations.                       \}\par \par     INTERFACE\par \par       USES\par         Types, }{\b\f22\fs18 SAGlobals}{\f22\fs18 ;\par \par       CONST\par         kAccumulate = 0;  \{These are the control messages.\}\par         kFirstTime = 1;\par         kLastTime = 2;\par \par       FUNCTION AccSquares (parm: Longint; message: Integer;\par             VAR A5Ref: A5RefType) : Longint;\par \par     IMPLEMENTATION\par       \{ Define global storage to retain a running \}\par       \{ total over multiple calls to the module.  \}\par       }{\b\f22\fs18 VAR accumulation : Longint;\par }{\f22\fs18 \par }\page {\f22\fs18       FUNCTION AccSquares (parm: Longint; }{\b\f22\fs18 message: Integer;\par }{\f22\fs18             }{\b\f22\fs18 VAR A5Ref: A5RefType}{\f22\fs18 ) : Longint;\par       VAR\par         }{\b\f22\fs18 oldA5: Longint;\par }{\f22\fs18       BEGIN\par         }{\b\f22\fs18 IF message = kFirstTime THEN MakeA5World(A5Ref);\par }{\f22\fs18         }{\b\f22\fs18 oldA5 := SetA5World(A5Ref);\par }{\f22\fs18           IF message = kFirstTime THEN accumulation := 0;\par           accumulation := accumulation + (parm * parm);\par           AccSquares := accumulation;\par         }{\b\f22\fs18 RestoreA5World(oldA5, A5Ref);\par }{\f22\fs18         }{\b\f22\fs18 IF message = kLastTime THEN DisposeA5World(A5Ref);\par }{\f22\fs18       END;\par     END.\par }\pard \qj\li180\ri-900 {\par }{\b Persist.make\par }{\par This is the makefile for the }{\f22 Persist}{ module.\par \par }\pard \li180\ri-900 {\f22\fs18     #   File:       Persist.make\par     #   Target:     Persist\par     #   Sources:    Persist.p\par \par     OBJECTS = Persist.p.o\par \par     Persist \'c4\'c4 Persist.make \{OBJECTS\}\par       Link -w -t '????' -c '????' -rt CUST=129 -m ACCSQUARES -sg Persist \'b6\par         \{OBJECTS\} \'b6\par         "\{Libraries\}"Runtime.o \'b6\par         "\{Libraries\}"Interface.o \'b6\par         "\{PLibraries\}"SANELib.o \'b6\par         "\{PLibraries\}"PasLib.o \'b6\par         "\{MyLibraries\}"SAGlobals.o \'b6\par         -o Persist\par     Persist.p.o \'c4 Persist.make Persist.p\par        Pascal -i "\{MyInterfaces\}" Persist.p\par }\pard \qj\li180\ri-900 {\par }{\b BigBro; FORWARD;\par }{\par The third case is illustrated by an }{\f22 'INIT'}{ using arbitrary Toolbox managers to present a user interface.  A working example is too long to present here, but an example is included at the end of the discussion.  The process, however, is no more difficult than the examples previously given; there is simply more intervening code to accomplish an interesting task.  An }{\f22 'INIT'}{ may simply call }{\f22 OpenA5World}{ upon entry and }{\f22 CloseA5World}{ before exiting.  Everything between can then be just like an application:  }{\f22 _InitGraf}{, }{\f22 _InitWindows}{, and so on.  An }{\f22 'INIT'}{ should be careful, though, to restore the }{\f22 GrafPort}{ to its initial value before exiting.\par \par }{\b Dashing Aside the Curtain, or Revealing the Wizard\par }{\par Building an }{\f22 A5}{ world would seem to be fairly complicated, but most of the necessary code is already written.  Much of it is in the MPW library called Runtime.o.  Actually, this makes sense, since applications have }{\f22 A5}{ worlds and the programmer doesn\rquote t have to do anything special to set them up.  Only in the case of stand-alone modules does this become the responsibility of the programmer.  What\rquote s not in the MPW library is the initial allocation of space for an }{\f22 A5}{ world.  For an application, this is done by the Segment Loader.  A stand-alone module can emulate the entire process by using bit of glue code around calls to the appropriate routines in Runtime.o.  This is the entire point of the }{\f22 SAGlobals}{ unit.  }{\f22 SAGlobals}{ makes it very easy to use globals in stand-alone code because it automates the process of allocating space for globals and initializes them the same way an application would.  The Pascal source code for }{\f22 SAGlobals}{ is published here.  DTS can also provide the source code in C, as well as simplified Pascal and C headers and the compiled object library.\par \par }\pard \li180\ri-900 {\f22\fs18     \{ Stand-alone code modules which need to use global variables\par       may include the interfaces in this unit. Such code modules\par       must also be linked with Runtime.o and SAGlobals.o. \}\par \par     UNIT SAGlobals;\par \par     INTERFACE\par \par       USES\par         Types, Memory, OSUtils;\par \par       TYPE\par         A5RefType = Handle;\par \par       \{ MakeA5World allocates space for an A5 world based on the\par         size of the global variables defined by the module and its\par         units. If sufficient space is not available, MakeA5World\par         returns NIL for A5Ref and further initialization is aborted. \}\par       PROCEDURE MakeA5World (VAR A5Ref: A5RefType);\par \par       \{ SetA5World locks down a previously-allocated handle containing\par         an A5 world and sets the A5 register appropriately. The return\par         value is the old value of A5 and the client should save it for\par         use by RestoreA5World. \}\par       FUNCTION SetA5World (A5Ref: A5RefType) : Longint;\par \par       \{ RestoreA5World restores A5 to its original value (which the\par         client should have saved) and unlocks the A5 world to avoid\par         heap fragmentation in cases where the world is used again. \}\par       PROCEDURE RestoreA5World (oldA5: Longint; A5Ref: A5RefType);\par \par       \{ DisposeA5World simply disposes of the A5 world handle. \}\par       PROCEDURE DisposeA5World (A5Ref: A5RefType);\par \par       \{ OpenA5World combines MakeA5World and SetA5World for the majority\par         of cases in which these two routines are called consecutively. An\par         exception is when a single A5 world is invoked many times. In this\par         case, the world is only created once with MakeA5World and it is\par         invoked each time by SetA5World. Most developers will find it easier\par         just to call OpenA5World and CloseA5World at the end. If the memory\par         allocation request fails, OpenA5World returns NIL for A5Ref and zero\par         in the function result. \}\par       FUNCTION OpenA5World (VAR A5Ref: A5RefType) : Longint;\par \par       \{ CloseA5World is the dual of OpenA5World. It combines RestoreA5World\par         and DisposeA5World. Again, in certain cases it may be necessary to\par         call those two routines explicitly, but most of the time CloseA5World\par         is all that is required. \}\par       PROCEDURE CloseA5World (oldA5: Longint; A5Ref: A5RefType);\par \par     IMPLEMENTATION\par \par       CONST\par         kAppParmsSize = 32;\par \par       FUNCTION A5Size : Longint;\par         C;  EXTERNAL;    \{ in MPW's Runtime.o \}\par \par }\page {\f22\fs18       PROCEDURE A5Init (myA5: Ptr);\par         C;  EXTERNAL;    \{ in MPW's Runtime.o \}\par \par       PROCEDURE MakeA5World (VAR A5Ref: A5RefType);\par       BEGIN\par         A5Ref := NewHandle(A5Size);\par         \{ The calling routine must check A5Ref for NIL! \}\par         IF A5Ref <> NIL THEN\par           BEGIN\par             HLock(A5Ref);\par             A5Init(Ptr(Longint(A5Ref^) + A5Size - kAppParmsSize));\par             HUnlock(A5Ref);\par           END;\par       END;\par \par       FUNCTION SetA5World (A5Ref: A5RefType) : Longint;\par       BEGIN\par         HLock(A5Ref);\par         SetA5World := SetA5(Longint(A5Ref^) + A5Size - kAppParmsSize);\par       END;\par \par       PROCEDURE RestoreA5World (oldA5: Longint; A5Ref: A5RefType);\par       BEGIN\par         IF Boolean (SetA5(oldA5)) THEN;    \{ side effect only \}\par         HUnlock(A5Ref);\par       END;\par \par       PROCEDURE DisposeA5World (A5Ref: A5RefType);\par       BEGIN\par         DisposHandle(A5Ref);\par       END;\par \par       FUNCTION OpenA5World (VAR A5Ref: A5RefType) : Longint;\par       BEGIN\par         MakeA5World(A5Ref);\par         IF A5Ref <> NIL THEN\par           OpenA5World := SetA5World(A5Ref)\par         ELSE\par           OpenA5World := 0;\par       END;\par \par       PROCEDURE CloseA5World (oldA5: Longint; A5Ref: A5RefType);\par       BEGIN\par         RestoreA5World(oldA5, A5Ref);\par         DisposeA5World(A5Ref);\par       END;\par \par     END.\par }\pard \qj\li180\ri-900 {\par It is tempting to reduce the entire globals issue to this cookbook recipe.  The preceding examples may tend to reinforce this view, but a solid theoretical understanding may be indispensable depending on what sort of code goes between }{\f22 MakeA5World}{ and }{\f22 DisposeA5World}{.  In the Sorter example at the end of this discussion, for instance, an }{\f22 'XCMD'}{ makes callbacks to HyperCard.  There is a similar mechanism between Apple File Exchange and custom translators.  When making these callbacks, it is necessary to temporarily restore the host\rquote s }{\f22 A5}{ world.  Otherwise, the host application bombs when it finds a different set of variables referenced by }{\f22 A5}{.  Calling }{\f22 SetA5}{ before and after a callback solves the problem, but neither the problem nor the solution is exactly part of the }{\f22 SAGlobals}{ recipe.  Hence, if a programmer chooses to use the }{\f22 SAGlobals}{ unit without understanding how and why it works, he most likely gets in a lot of trouble and ends up writing to Apple to ask why it doesn\rquote t work right.  As the best mathematics and physics students generally attest: don\rquote t just memorize formulas\emdash }{\i know the concepts behind them.\par }{\par }{\f22 A5Size}{ and }{\f22 A5Init}{ are the MPW library routines necessary to set up and initialize an }{\f22 A5}{ world.  }{\f22 A5Size}{ determines how much memory is required for the }{\f22 A5}{ world.  This memory consists of two parts:  memory for globals and memory for application parameters.  }{\f22 A5Init}{ takes a pointer to the }{\f22 A5}{ globals and initializes them to the appropriate values.  How this works needs a little explaining.\par \par When MPW links an application together, it has to describe what the globals area should look like.  At the very least, it needs to keep track of how large the globals section should be.  In addition, it may need to specify what values to put into the globals area.  Normally, this means setting everything to zero, but some languages like C allow specification of preinitialized globals.  The linker normally creates a packed data block that describes all of this and places it into a segment called }{\f22 %A5Init}{.  Also included in this segment are the routines called by the MPW run-time initialization package to act upon this data.  }{\f22 A5Size}{ and }{\f22 A5Init}{ are two such routines.  }{\f22 A5Size}{ looks at the field that holds the unpacked size of the data and returns it to the caller.  }{\f22 A5Init}{ is responsible for unpacking the data into the globals section.  In the case of a stand-alone module, all code and data needs to be packed into a single segment or resource, so }{\f22 %A5Init}{ is not used.  The linker option }{\f22 -sg}{ is used to make sure that everything is in the same resource.  The MPW Commando interface to CreateMake is very good about specifying this automatically, but the programmer must remember to specify this if he creates his own makefiles.\par \par The rest of the }{\f22 SAGlobals}{ unit is mostly self-explanatory.  The Memory Manager calls straightforwardly allocate the amount of space indicated by }{\f22 A5Size}{, and lock the handle down when in use by the module.  If the math performed by }{\f22 MakeA5World}{ and }{\f22 SetA5World}{ seems just a little too cosmic in nature, don\rquote t be alarmed.  It\rquote s really quite simple.  Referring back to Figure 2, }{\f22 A5}{ needs to point to the boundary between the global variables and the application parameters.  Since the application parameters, including the pointer to QuickDraw globals, are 32 bytes long, the formula should become clear. It\rquote s just }{\f22 starting address + block length \endash  32}{.\par \par As demonstrated in the examples, a module can simply call }{\f22 MakeA5World}{ to begin building its own }{\f22 A5}{ world, and it can call }{\f22 SetA5World}{ to invoke it and make it active.  What is not demonstrated particularly well in the examples is that the module should check }{\f22 A5Ref}{ to see if it is }{\f22 NIL}{.  If so, there is not space to allocate the }{\f22 A5}{ world, and the module needs to abort gracefully or find another way of getting its job done.  Also, the programmer should be aware that }{\f22 A5Ref}{ is }{\b not}{ an actual }{\f22 A5}{ value.  It is a reference to an }{\f22 A5}{ world as its name implies.  The actual value of }{\f22 A5}{ is calculated whenever that world is invoked, as described in the preceding paragraph.\par \par \par }{\b\fs28 Are We There Yet?\par }{\par As the preceding sections indicate, stand-alone code is one of the more esoteric areas of Macintosh programming.  Many more pages could be devoted to the subject, and they probably will be eventually, but there should be enough information here to get most developers past the initial hurdles of creating stand-alone modules and interfacing with an environment biased toward full-blown applications.  As always, suggestions for additional topics are welcome and will be incorporated as demand requires and resources permit.\par \par Party on, Dudes.\par \par \par }\page {\b\fs28 LazyTest\par }{\par }{\b LazyTest.p\par }{\par This is a very simple program to demonstrate use of the }{\f22 LazyPass}{ module documented earlier.  Things to watch out for are standard I/O (}{\f22 ReadLn}{ and }{\f22 WriteLn}{) and error checking (or lack thereof).  This is a bare-bones example of how to load and call a stand-alone module.  Don\rquote t expect anything more.\par \par }\pard \li180\ri-900 {\f22\fs18     PROGRAM LazyTest;\par     USES\par       Types, Resources, Memory, OSUtils;\par \par     VAR\par       a, c: Real;\par       h1: Handle;\par \par       FUNCTION CallModule (parm: Real; modHandle: Handle) : Real;\par       INLINE $205F,    \{ MOVEA.L  (A7)+,A0         pop handle off stack        \}\par              $2050,    \{ MOVEA.L  (A0),A0   dereference to get address of XCMD \}\par              $4E90;    \{ JSR      (A0)        call XCMD, leaving pb on stack   \}\par \par     BEGIN\par       Write('Circumference:');\par       ReadLn(c);\par \par       h1 := GetResource('CUST',128);\par       HLock(h1);\par       a := CallModule(c,h1);\par       HUnlock(h1);\par       WriteLn('Area: ',a);\par     END.\par }\pard \qj\li180\ri-900 {\par }{\b LazyTest.make\par }{\par The accompanying makefile is pretty basic, the kind of thing one expects from CreateMake.  The only notable addition is a directive to include the }{\f22 LazyPass}{ module in the final application.  This avoids the need to paste }{\f22 LazyPass}{ into the application manually with ResEdit.  It is also an example of a very powerful feature of the MPW scripting language, which allows the output of one command to be \ldblquote piped\rdblquote  into the input of another.\par \par }\pard \li180\ri-900 {\f22\fs18     #   File:       LazyTest.make\par     #   Target:     LazyTest\par     #   Sources:    LazyTest.p\par \par     OBJECTS = LazyTest.p.o\par \par     LazyTest \'c4\'c4 LazyTest.make LazyPass\par       Echo 'Include "LazyPass";' | Rez -o LazyTest\par \par     LazyTest \'c4\'c4 LazyTest.make \{OBJECTS\}\par       Link -w -t APPL -c '????' \'b6\par         \{OBJECTS\} \'b6\par         "\{Libraries\}"Runtime.o \'b6\par         "\{Libraries\}"Interface.o \'b6\par         "\{PLibraries\}"SANELib.o \'b6\par         "\{PLibraries\}"PasLib.o \'b6\par         -o LazyTest\par     LazyTest.p.o \'c4 LazyTest.make LazyTest.p\par        Pascal  LazyTest.p\par }\pard \qj\li180\ri-900 {\par \par }{\b\fs28 PersistTest\par }{\par }{\b PersistTest.p\par }{\par }{\f22 PersistTest}{ is an equally minimal application to demonstrate the }{\f22 Persist}{ module, also documented earlier.\par \par }\pard \li180\ri-900 {\f22\fs18     PROGRAM PersistTest;\par \par     USES\par       Types, Resources, Memory, OSUtils;\par \par     CONST\par       N = 5;\par       kAccumulate = 0;\tab \{These are the control messages.\}\par       kFirstTime = 1;\par       kLastTime = 2;\par \par     VAR\par       i : Integer;\par       acc : Longint;\par       h1, otherA5: Handle;\par \par       FUNCTION CallModule (parm: Longint; message: Integer; VAR otherA5: Handle;\par         modHandle: Handle) : Longint;\par       INLINE $205F,    \{ MOVEA.L  (A7)+,A0         pop handle off stack        \}\par              $2050,    \{ MOVEA.L  (A0),A0   dereference to get address of XCMD \}\par              $4E90;    \{ JSR      (A0)        call XCMD, leaving pb on stack   \}\par \par     BEGIN\par       h1 := GetResource('CUST',129);\par       MoveHHi(h1);\par       HLock(h1);\par \par       FOR i := 1 TO N DO\par         BEGIN\par           CASE i OF\par             1: acc := CallModule(i,kFirstTime,otherA5,h1);\par             N: acc := CallModule(i,kLastTime,otherA5,h1);\par           OTHERWISE\par             acc := CallModule(i,kAccumulate,otherA5,h1);\par           END;\par           WriteLn('SumSquares after ',i,' = ',acc);\par         END;\par       HUnlock(h1);\par     END.\par }\pard \qj\li180\ri-900 {\par }\page {\b PersistTest.make\par }{\par This makefile presents nothing new and is provided for the sake of completeness.\par \par }\pard \li180\ri-900 {\f22\fs18     #   File:       PersistTest.make\par     #   Target:     PersistTest\par     #   Sources:    PersistTest.p\par \par     OBJECTS = PersistTest.p.o\par \par     PersistTest \'c4\'c4 PersistTest.make Persist\par       Echo 'Include "Persist";' | Rez -o PersistTest\par \par     PersistTest \'c4\'c4 PersistTest.make \{OBJECTS\}\par       Link -w -t APPL -c '????' \'b6\par         \{OBJECTS\} \'b6\par         "\{Libraries\}"Runtime.o \'b6\par         "\{Libraries\}"Interface.o \'b6\par         "\{PLibraries\}"SANELib.o \'b6\par         "\{PLibraries\}"PasLib.o \'b6\par         -o PersistTest\par     PersistTest.p.o \'c4 PersistTest.make PersistTest.p\par        Pascal  PersistTest.p\par }\pard \qj\li180\ri-900 {\par \par }{\b\fs28 Sorter\par }{\par }{\b Sorter.p\par }{\par }{\f22 Sorter}{ is an example }{\f22 'XCMD'}{ which demonstrates the concept of persistent globals across multiple invocations.  It also illustrates how stand-alone modules must handle callbacks to a host application.  This is evidenced by the }{\f22 SetA5}{ instructions bracketing HyperCard callback routines, such as }{\f22 ZeroToPas}{, }{\f22 SetGlobal}{, or user routines incorporating such calls.\par \par }\pard \li180\ri-900 {\f22\fs18 $Z+\} \{ This allows the Linker to find "ENTRYPOINT" without our having to put it\par        in the INTERFACE section \}\par \par UNIT Fred;\par \par   INTERFACE\par \par     USES\par       Types, Memory, OSUtils, HyperXCmd, SAGlobals;\par \par   IMPLEMENTATION\par \par     TYPE\par       LongArray = ARRAY [0..0] OF Longint; \{ These define our list of entries \}\par       LongPointer = ^LongArray;\par       LongHandle = ^LongPointer;\par \par     CONST\par       kFirstTime = 1;     \{ being called for the first time. Initialize. \}\par       kLastTime = 2;      \{ being called for the last time. Clean up. \}\par       kAddEntry = 3;      \{ being called to add an entry to our list to sort. \}\par       kSortEntries = 4;   \{ being called to sort and display our list. \}\par \par }\page {\f22\fs18       kCommandIndex = 1;  \{ Parameter 1 holds our command number. \}\par       kA5RefIndex = 2;    \{ Parameter 2 holds our A5 world reference. \}\par       kEntryIndex = 3;    \{ Parameter 3 holds a number to add to our list. \}\par \par     VAR\par       gHostA5: Longint; \{ The saved value of our host's (HyperCard's) A5. \}\par       gNumOfEntries: Longint; \{ The number of entries in our list. \}\par       gEntries: LongHandle; \{ Our list of entries. Gets expanded as needed. \}\par \par       \{ Forward reference to the main procedure. This is so we can jump to\par       it from ENTRYPOINT, which represents the beginning of the XCMD, and is\par       what HyperCard calls when it calls us. \}\par \par     PROCEDURE Sorter(paramPtr: XCmdPtr);\par       FORWARD;\par \par     PROCEDURE ENTRYPOINT(paramPtr: XCmdPtr);\par \par       BEGIN\par         Sorter(paramPtr);\par       END;\par \par     \{ Utility routines for using the HyperCard callbacks. There are some\par       functions that we need to perform many times, or would like to\par       encapsulate into little routines for clarity:\par \par         ValueOfExpression - given an index from 1 to 16, this evaluates the\par             expression of that parameter. This is used to scoop out the value\par             of the command selector, our A5 pointer, and the value of the\par             number we are to stick into our list of numbers to sort.\par \par         LongToZero - Convert a LONGINT into a C (zero delimited) string.\par             Returns a handle that contains that string.\par \par         SetGlobalAt - given the index to one of the 16 parameters and a\par             LONGINT, this routines sets the global found in that parameter to\par             the LONGINT.\par     \}\par \par     FUNCTION ValueOfExpression(paramPtr: XCmdPtr;\par                                index: integer): Longint;\par       VAR\par         tempStr: Str255;\par         tempHandle: Handle;\par \par       BEGIN\par         ZeroToPas(paramPtr, paramPtr^.params[index]^, tempStr);\par         tempHandle := EvalExpr(paramPtr, tempStr);\par         ZeroToPas(paramPtr, tempHandle^, tempStr);\par         DisposHandle(tempHandle);\par         ValueOfExpression := StrToLong(paramPtr, tempStr);\par       END;\par \par     FUNCTION LongToZero(paramPtr: XCmdPtr;\par                         long: Longint): Handle;\par \par       VAR\par         tempStr: Str255;\par \par       BEGIN\par         LongToStr(paramPtr, long, tempStr);\par         LongToZero := PasToZero(paramPtr, tempStr);\par       END;\par \par     PROCEDURE SetGlobalAt(paramPtr: XCmdPtr;\par                           index: integer;\par                           long: Longint);\par \par       VAR\par         globalName: Str255;\par         hLong: Handle;\par \par       BEGIN\par         ZeroToPas(paramPtr, paramPtr^.params[index]^, globalName);\par         hLong := LongToZero(paramPtr, long);\par         SetGlobal(paramPtr, globalName, hLong);\par         DisposHandle(hLong);\par       END;\par \par     \{ These 4 routines are called according to the command passed to the XCMD:\par \par         Initialize - used to initialize our globals area. A5Init will clear\par             our globals to zero, and set up any pre-initialized variables if we\par             wrote our program in C or Assembly, but it can't do everything. For\par             instance, in this XCMD, we need to create a handle to hold our list\par             of entries.\par         AddAnEntry - Takes the value represented by the 3 parameters passed to\par             us by HyperCard and adds it to our list.\par         SortEntries - Sorts the entries we have so far. Converts them into a\par             string and tells HyperCard to display them in the message box.\par         FreeData - We just receive the message saying that we are never going\par             to be called again. Therefore, we must get rid of any memory we\par             have allocated for our own use.\par     \}\par \par     PROCEDURE Initialize;\par \par       BEGIN\par         gEntries := LongHandle(NewHandle(0));\par         gNumOfEntries := 0;\par       END;\par \par     PROCEDURE AddAnEntry(paramPtr: XCmdPtr);\par \par       VAR\par         ourA5: Longint;\par         tempStr: Str255;\par         temp: Longint;\par \par       BEGIN\par         ourA5 := SetA5(gHostA5);\par         temp := ValueOfExpression(paramPtr, kEntryIndex);\par         ourA5 := SetA5(ourA5);\par \par         SetHandleSize(Handle(gEntries), (gNumOfEntries + 1) * 4);\par         \{$PUSH\} \{$R-\}\par         gEntries^^[gNumOfEntries] := temp;\par         \{$POP\}\par         gNumOfEntries := gNumOfEntries + 1;\par       END;\par \par }\page {\f22\fs18     PROCEDURE SortEntries(paramPtr: XCmdPtr);\par \par       VAR\par         ourA5: Longint;\par         i, j: integer;\par         fullStr: Str255;\par         tempStr: Str255;\par         temp: Longint;\par \par       BEGIN\par         IF gNumOfEntries > 1 THEN\par           BEGIN\par           \{$PUSH\} \{$R-\}\par           FOR i := 0 TO gNumOfEntries - 2 DO\par             BEGIN\par             FOR j := i + 1 TO gNumOfEntries - 1 DO\par               BEGIN\par               IF gEntries^^[i] > gEntries^^[j] THEN\par                 BEGIN\par                 temp := gEntries^^[i];\par                 gEntries^^[i] := gEntries^^[j];\par                 gEntries^^[j] := temp;\par                 END;\par               END;\par             END;\par           \{$POP\}\par           END;\par \par         IF gNumOfEntries > 0 THEN\par           BEGIN\par           fullStr := '';\par           FOR i := 0 TO gNumOfEntries - 1 DO\par             BEGIN\par             \{$PUSH\} \{$R-\}\par             temp := gEntries^^[i];\par             \{$POP\}\par             ourA5 := SetA5(gHostA5);\par             NumToStr(paramPtr, temp, tempStr);\par             ourA5 := SetA5(ourA5);\par             fullStr := concat(fullStr, ', ', tempStr);\par             END;\par           delete(fullStr, 1, 2); \{ remove the first ", " \}\par           ourA5 := SetA5(gHostA5);\par           SendHCMessage(paramPtr, concat('put "', fullStr, '"'));\par           ourA5 := SetA5(ourA5);\par           END;\par       END;\par \par     PROCEDURE FreeData;\par \par       BEGIN\par         DisposHandle(Handle(gEntries));\par       END;\par \par     \{ Main routine. Big Cheese. Head Honcho. The Boss. The Man with all the\par       moves. You get the idea. This is the controlling routine. It first\par       checks to see if we have the correct number of parameters (sort of).\par       If that's OK, then it either creates a new A5 world and initializes it,\par       or it sets up one that we've previously created.  It then dispatches to\par       the appropriate routine, depending on what command was passed to us.\par       Finally, it restores the host application's A5 world, and disposes of\par       ours if this is the last time we are being called. \}\par \par     PROCEDURE Sorter(paramPtr: XCmdPtr);\par \par       VAR\par         command: integer;\par         A5Ref: A5RefType;\par         errStr: Str255;\par         A5Name: Str255;\par \par       BEGIN \{Main\}\par \par         WITH paramPtr^ DO\par           IF (paramCount < 2) OR (paramCount > 3) THEN\par             BEGIN\par             errStr := 'Correct usage is: "Sorter <function> <A5> [<entry>]"';\par             paramPtr^.returnValue := PasToZero(paramPtr, errStr);\par             EXIT(Sorter); \{leave the XCMD\}\par             END;\par \par         command := ValueOfExpression(paramPtr, kCommandIndex);\par \par         IF command = kFirstTime THEN\par           BEGIN\par           MakeA5World(A5Ref);\par           SetGlobalAt(paramPtr, kA5RefIndex, Longint(A5Ref));\par           END\par         ELSE\par           BEGIN\par           A5Ref := A5RefType(ValueOfExpression(paramPtr, kA5RefIndex));\par           END;\par \par         IF (A5Ref = NIL) THEN\par           BEGIN\par           errStr := 'Could not get an A5 World!!!';\par           paramPtr^.returnValue := PasToZero(paramPtr, errStr);\par           EXIT(Sorter); \{leave the XCMD\}\par           END;\par \par         gHostA5 := SetA5World(A5Ref);\par         CASE command OF\par           kFirstTime: Initialize;\par           kAddEntry: AddAnEntry(paramPtr);\par           kSortEntries: SortEntries(paramPtr);\par           kLastTime: FreeData;\par         END;\par         RestoreA5World(gHostA5, A5Ref);\par \par         IF command = kLastTime THEN DisposeA5World(A5Ref)\par \par       END; \{main\}\par END.\par }\pard \qj\li180\ri-900 {\par }{\b Sorter.make\par }{\par The makefile for }{\f22 Sorter}{ is fairly straightforward, but CreateMake cannot generate all of it automatically.  Be sure to link with both HyperXLib.o and SAGlobals.o, and account for any custom directories to search for interfaces.  In most of the examples, there are two MPW Shell variables, }{\f22 MyInterfaces}{ and }{\f22 MyLibraries}{ which represent the directories containing the }{\f22 SAGlobals}{ headers and library, respectively.  Someone following along with these examples would need to define these Shell variables, possibly in his UserStartup file, or replace the occurrences with the name of whatever directory actually contains the necessary }{\f22 SAGlobals}{ files.\par \par }\pard \li180\ri-900 {\f22\fs18 #   File:       Sorter.make\par #   Target:     Sorter\par #   Sources:    Sorter.p\par \par OBJECTS = Sorter.p.o\par \par Sorter \'c4\'c4 Sorter.make \{OBJECTS\}\par   Link -w -t '????' -c '????' -rt XCMD=256 -m ENTRYPOINT -sg Sorter \'b6\par     \{OBJECTS\} \'b6\par     "\{Libraries\}"Runtime.o \'b6\par     "\{Libraries\}"Interface.o \'b6\par     "\{PLibraries\}"SANELib.o \'b6\par     "\{PLibraries\}"PasLib.o \'b6\par     "\{Libraries\}"HyperXLib.o \'b6\par     "\{MyLibraries\}"SAGlobals.o \'b6\par     -o Sorter\par Sorter.p.o \'c4 Sorter.make Sorter.p\par    Pascal -i "\{MyInterfaces\}" Sorter.p\par }\pard \qj\li180\ri-900 {\par }{\b A Sample HyperCard Script Using Sorter\par }{\par To test }{\f22 Sorter}{, it is necessary to create a simple HyperCard stack.  After creating a new stack under HyperCard\rquote s File menu, use the button tool to create a new button and associate it with the following script.  Now use ResEdit to paste the }{\f22 'XCMD'}{ resource \ldblquote Sorter\rdblquote  into the stack and it\rquote s ready for experimentation.\par \par }\pard \li180\ri-900 {\f22\fs18 on mouseUp\par   global A5\par   Sorter 1, "A5"       -- Initialize that puppy\par   if the result is empty then\par     Sorter 3, A5, 6    -- Add some numbers to the list\par     Sorter 3, A5, 2\par     Sorter 3, A5, 9\par     Sorter 3, A5, 12\par     Sorter 3, A5, 7\par     Sorter 4, A5       -- sort them and print them\par     Sorter 2, A5       -- Dispose of our data\par   else\par     put the result\par   end if\par end mouseUp\par }\pard \qj\li180\ri-900 {\par \par \par }{\b BigBro.p\par }{\par }{\f22 BigBro}{ may look a bit familiar because it performs the same function as the sample INIT offered early in the preceding discussion.  However, it has the added feature of providing a user interface, or a dialog at least, during the startup sequence.  This tends to make it very obnoxious, and DTS discourages this sort of thing on human interface grounds.  Nonetheless, it is an interesting case study.  It is also the first example in which a stand-alone code resource uses other resources.\par \par }{\f22\fs18 UNIT BigBro;\par \par INTERFACE\par \par }\page {\f22\fs18   USES\par     Types, SAGlobals, OSUtils,\par     QuickDraw, Fonts, Windows, Menus, TextEdit, Dialogs,\par     Resources, Sound, ToolUtils;\par \par   PROCEDURE BeAPest;\par \par IMPLEMENTATION\par \par   PROCEDURE BeAPest;\par   CONST\par     kBigBroDLOG = 128;\par   VAR\par     A5Ref: A5RefType;\par     oldA5: Longint;\par     numSnds, i, itemHit: Integer;\par     theSnd: Handle;\par     playStatus: OSErr;\par     orwell: DialogPtr;\par \par   BEGIN\par     IF NOT Button THEN BEGIN\par       oldA5 := OpenA5World(A5Ref);\par       IF A5Ref <> NIL THEN BEGIN\par         InitGraf(@thePort);\par         InitFonts;\par         InitWindows;\par         InitMenus;\par         TEInit;\par         InitDialogs(NIL);\par         InitCursor;\par         orwell := GetNewDialog(kBigBroDLOG, NIL, WindowPtr(-1));\par         numSnds := CountResources('snd ');\par         FOR i := 1 TO numSnds DO BEGIN\par           theSnd := GetIndResource('snd ',i);\par           IF theSnd <> NIL THEN\par             playStatus := SndPlay(NIL,theSnd,FALSE);\par           END;\par         REPEAT\par           ModalDialog(NIL, itemHit);\par         UNTIL itemHit = 1;\par         DisposDialog(orwell);\par       CloseA5World(oldA5, A5Ref);\par       END;\par     END;\par   END;\par END.\par }{\par }{\b BigBro.r\par }{\par This is the Rez input file necessary to create the 'DLOG' and 'DITL' resources used by }{\f22 BigBro}{.\par \par }\pard \li180\ri-900 {\f22\fs18 resource 'DLOG' (128) \{\par   \{84, 124, 192, 388\},\par   dBoxProc,\par   visible,\par   noGoAway,\par   0x0,\par   128,\par   ""\par \};\par }{\f3 \par }{\f22\fs18 resource 'DITL' (128) \{\par   \{  /* array DITLarray: 2 elements */\par     /* [1] */\par     \{72, 55, 93, 207\},\par     Button \{\par       enabled,\par       "Continue Booting"\par     \},\par     /* [2] */\par     \{13, 30, 63, 237\},\par     StaticText \{\par       disabled,\par       "This is an exaggerated case of the type "\par       "of INIT which bothers me more than anyth"\par       "ing else."\par     \}\par   \}\par \};\par }\pard \qj\li180\ri-900 {\par }{\b BigBro.make\par }{\par The makefile for }{\f22 BigBro}{ is a little simpler than that of }{\f22 Sorter}{, but includes an extra directive to include the dialog resources using Rez.  Refer to the }{\f22 Sorter}{ example for notes on the }{\f22 MyInterfaces}{ and }{\f22 MyLibraries}{ Shell variables.\par \par }\pard \li180\ri-900 {\f22\fs18 #   File:       BigBro.make\par #   Target:     BigBro\par #   Sources:    BigBro.p\par \par \par OBJECTS = BigBro.p.o\par \par BigBro \'c4\'c4 BigBro.make BigBro.r\par   Rez -o BigBro "\{RIncludes\}"Types.r BigBro.r\par \par \par BigBro \'c4\'c4 BigBro.make \{OBJECTS\}\par   Link -w -t INIT -c '????' -rt INIT=128 -ra =resLocked -m BEAPEST -sg BigBro \'b6\par     \{OBJECTS\} \'b6\par     "\{Libraries\}"Runtime.o \'b6\par     "\{Libraries\}"Interface.o \'b6\par     "\{PLibraries\}"SANELib.o \'b6\par     "\{PLibraries\}"PasLib.o \'b6\par     "\{MyLibraries\}"SAGlobals.o \'b6\par     -o BigBro\par BigBro.p.o \'c4 BigBro.make BigBro.p\par    Pascal -i "\{MyInterfaces\}" BigBro.p\par }\pard \qj\li180\ri-900 {\par \par }\pard \li180\ri-900 \page {\b\fs28 MyWindowDef\par }\pard \qj\li180\ri-900 {\par }{\b MyWindowDef.a\par }{\par Writing a }{\f22 'WDEF'}{ is like writing an }{\f22 'INIT'}{, except that }{\f22 'WDEF'}{ resources have standard headers that are incorporated into the code.  In this example, the }{\f22 'WDEF'}{ is the Pascal }{\f22 MyWindowDef}{.  To create the header, use an assembly language stub:\par }\pard \li180\ri-900 {\f22\fs18 \par     StdWDEF    MAIN EXPORT                 ; this will be the entry point\par                IMPORT MyWindowDef          ; name of Pascal FUNCTION that is the WDEF\par                                            ; we IMPORT externally referenced routines\par                                            ; from Pascal (in this case, just this one)\par                BRA.S    @0                 ; branch around the header to the actual code\par                DC.W     0                  ; flags word\par                DC.B     'WDEF'             ; type\par                DC.W     3                  ; ID number\par                DC.W     0                  ; version\par     @0         JMP      MyWindowDef        ; this calls the Pascal WDEF\par                END\par }\pard \qj\li180\ri-900 {\par }{\b MyWindowDef.p\par }{\par Now for the Pascal source for the }{\f22 'WDEF'}{.  Only the shell of what needs to be done is listed, the actual code is left as an exercise for the reader (for further information about writing a }{\f22 'WDEF'}{, see }{\i Inside Macintosh}{, Volume I, The Window Manager (pp. 297-302) and Volume V, The Window Manager (pp. 205-206).\par \par }\pard \li180\ri-900 {\f22\fs18     UNIT WDef;\par \par     INTERFACE\par \par       USES MemTypes, QuickDraw, OSIntf, ToolIntf;\par \par     \{this is the only external routine\}\par       FUNCTION MyWindowDef(varCode: Integer; theWindow: WindowPtr; message: Integer;\par                            param: LongInt): LongInt; \{As defined in IM p. I-299\}\par \par     IMPLEMENTATION\par \par       FUNCTION MyWindowDef(varCode: Integer; theWindow: WindowPtr; message: Integer;\par                            param: LongInt): LongInt;\par \par           RectPtr = ^Rect;\par \par         VAR\par           aRectPtr : RectPtr;\par \par       \{here are the routines that are dispatched to by MyWindowDef\}\par \par         PROCEDURE DoDraw(theWind: WindowPtr; DrawParam: LongInt);\par           BEGIN \{DoDraw\}\par             \{Fill in the code!\}\par           END; \{DoDraw\}\par \par         FUNCTION DoHit(theWind: WindowPtr; theParam: LongInt): LongInt;\par           BEGIN \{DoHit\}\par             \{Code for this FUNCTION goes here\}\par           END;  \{DoHit\}\par \par }\page {\f22\fs18         PROCEDURE DoCalcRgns(theWind: WindowPtr);\par           BEGIN \{DoCalcRgns\}\par             \{Code for this PROCEDURE goes here\}\par           END;  \{DoCalcRgns\}\par \par         PROCEDURE DoGrow(theWind: WindowPtr; theGrowRect: Rect);\par           BEGIN \{DoGrow\}\par             \{Code for this PROCEDURE goes here\}\par           END;  \{DoGrow\}\par \par         PROCEDURE DoDrawSize(theWind: WindowPtr);\par           BEGIN \{DoDrawSize\}\par             \{Code for this PROCEDURE goes here\}\par           END;  \{DoDrawSize\}\par \par       \{now for the main body to MyWindowDef\}\par       BEGIN  \{ MyWindowDef \}\par       \{case out on the message and jump to the appropriate routine\}\par         MyWindowDef := 0; \{initialize the function result\}\par \par         CASE message OF\par           wDraw:  \{ draw window frame\}\par             DoDraw(theWindow,param);\par \par           wHit:   \{ tell what region the mouse was pressed in\}\par             MyWindowDef := DoHit(theWindow,param);\par \par           wCalcRgns: \{ calculate structRgn and contRgn\}\par             DoCalcRgns(theWindow);\par \par           wNew:   \{ do any additional initialization\}\par             \{ we don\rquote t need to do any\} \par             ;\par \par           wDispose:\{ do any additional disposal actions\}\par             \{ we don\rquote t need to do any\}\par             ;\par \par           wGrow:  \{ draw window\rquote s grow image\}\par             BEGIN\par               aRectPtr := RectPtr(param);\par               DoGrow(theWindow,aRectPtr^);\par             END; \{CASE wGrow\}\par \par           wDrawGIcon:\{ draw Size box in content region\}\par             DoDrawSize(theWindow);\par \par         END; \{CASE\}\par       END; \{MyWindowDef\}\par END. \{of UNIT\}\par }\pard \qj\li180\ri-900 {\par }\page {\b MyWindowDef.make (Pascal Version)\par }{\par }\pard \li180\ri-900 {\f22\fs18     #   File:       MyWindowDef.make\par     #   Target:     MyWindowDef\par     #   Sources:    MyWindowDef.a MyWindowDef.p\par \par     OBJECTS = MyWindowDef.a.o MyWindowDef.p.o\par \par     MyWindowDef \'c4\'c4 MyWindowDef.make \{OBJECTS\}\par       Link -w -t '????' -c '????' -rt WDEF=3 -m STDWDEF -sg MyWindowDef \'b6\par         \{OBJECTS\} \'b6\par         -o MyWindowDef\par     MyWindowDef.a.o \'c4 MyWindowDef.make MyWindowDef.a\par        Asm  MyWindowDef.a\par     MyWindowDef.p.o \'c4 MyWindowDef.make MyWindowDef.p\par        Pascal  MyWindowDef.p\par }\pard \qj\li180\ri-900 {\par That\rquote s all there is to it.\par \par }{\b MyWindowDef.c\par }{\par Writing a }{\f22 'WDEF'}{ in MPW C is very similar to writing one in Pascal.  You can use the same assembly language header, and all you need to make sure of is that the main dispatch routine (in this case: }{\f22 MyWindowDef}{) is first in your source file.  Here\rquote s the same }{\f22 'WDEF'}{ shell in MPW C:\par \par }\pard \li180\ri-900 {\f22\fs18     /* first, the mandatory includes */\par     #include <types.h>\par     #include <quickdraw.h>\par     #include <resources.h>\par     #include <fonts.h>\par     #include <windows.h>\par     #include <menus.h>\par     #include <textedit.h>\par     #include <events.h>\par \par     /* declarations */\par     void DoDrawSize();\par     void DoGrow();\par     void DoCalcRgns();\par     long int DoHit();\par     void DoDraw();\par     /*---------------------- Main Proc within WDEF ----------------------*/\par     pascal long int MyWindowDef(varCode,theWindow,message,param)\par     short int    varCode;\par     WindowPtr    theWindow;\par     short int    message;\par     long int     param;\par     \{    /* MyWindowDef */\par \par       Rect       *aRectPtr;\par       long int   theResult=0;       /*this is what the function returns, init to 0 */\par \par }\page {\f22\fs18       switch (message) \par       \{\par         case wDraw:                 /* draw window frame*/\par           DoDraw(theWindow,param);\par           break;\par         case wHit:                  /* tell what region the mouse was pressed in*/\par           theResult = DoHit(theWindow,param);\par           break;\par         case wCalcRgns:             /* calculate structRgn and contRgn*/\par           DoCalcRgns(theWindow);\par           break;\par         case wNew:                  /* do any additional initialization*/\par           break;                    /* nothing here */\par         case wDispose:              /* do any additional disposal actions*/\par           break;                    /* we don't need to do any*/\par         case wGrow:                 /* draw window's grow image*/\par           aRectPtr = (Rect *)param;\par           DoGrow(theWindow,*aRectPtr);\par           break;\par         case wDrawGIcon:            /* draw Size box in content region*/\par           DoDrawSize(theWindow);\par           break;\par       \}  /* switch */\par       return theResult;\par     \}    /* MyWindowDef */\par \par     /* here are the routines that are dispatched to by MyWindowDef\par \par     /*--------------------------- DoDraw function -----------------------------*/\par     void DoDraw(WindToDraw,DrawParam)\par     WindowPtr    WindToDraw;\par     long int     DrawParam;\par \par     \{  /* DoDraw */\par           /* code for DoDraw goes here */\par     \}  /* DoDraw */\par \par     /*--------------------------- DoHit function -----------------------------*/\par     long int DoHit(WindToTest,theParam)\par     WindowPtr    WindToTest;\par     long int     theParam;\par \par     \{  /* DoHit */\par           /* code for DoHit goes here */\par     \}  /* DoHit */\par \par     /*------------------------ DoCalcRgns procedure --------------------------*/\par     void DoCalcRgns(WindToCalc)\par \par     \{  /* DoCalcRgns */\par           /* code for DoCalcRgns goes here */\par     \}  /* DoCalcRgns */\par \par     /*-------------------------- DoGrow procedure ----------------------------*/\par     void DoGrow(WindToGrow,theGrowRect)\par     WindowPtr    WindToGrow;\par     Rect         theGrowRect;\par \par     \{  /* DoGrow */\par           /* code for DoGrow goes here */\par     \}  /* DoGrow */\par \par     /*------------------------ DoDrawSize procedure --------------------------*/\par     void DoDrawSize(WindToDraw)\par     WindowPtr    WindToDraw; \par \par     \{  /* DoDrawSize */\par           /* code for DoDrawSize goes here */\par     \}  /* DoDrawSize */\par }\pard \qj\li180\ri-900 {\par }{\b MyWindowDef.make (C Version)\par }{\par }\pard \li180\ri-900 {\f22\fs18     #   File:       MyWindowDef.make\par     #   Target:     MyWindowDef\par     #   Sources:    MyWindowDef.a MyWindowDef.c\par \par     OBJECTS = MyWindowDef.a.o MyWindowDef.c.o\par \par     MyWindowDef \'c4\'c4 MyWindowDef.make \{OBJECTS\}\par       Link -w -t '????' -c '????' -rt WDEF=3 -m STDWDEF -sg MyWindowDef \'b6\par         \{OBJECTS\} \'b6\par         -o MyWindowDef\par     MyWindowDef.a.o \'c4 MyWindowDef.make MyWindowDef.a\par        Asm  MyWindowDef.a\par     MyWindowDef.c.o \'c4 MyWindowDef.make MyWindowDef.c\par        C  -w MyWindowDef.c\par }\page \pard \qj\li180\ri-900 {\par \par }{\b\fs28 Debugger 'FKEY'\par }{\par }{\b DebugKey.a\par }{\par DebugKey a very simple assembly-language example of how to write an }{\f22 'FKEY'}{ code resource, which traps to the debugger.  With this }{\f22 'FKEY'}{, you can enter the debugger using the keyboard rather than pressing the interrupt switch on your Macintosh.\par \par The build process is a little different for this example, as it links the }{\f22 'FKEY'}{ directly into the System file.  Another script can remove the }{\f22 'FKEY'}{ resource. If the prospect of turning MPW tools loose on the System file is just too much to bear, the }{\f22 'FKEY'}{ can be linked into a separate file and pasted into the System file with a more mainstream tool like ResEdit.\par \par }\pard \li180\ri-900 {\f22\fs18     ; File: DebugKey.a\par     ;\par     ; An FKEY to invoke the debugger via command-shift-8\par     ;\par     DebugKey    MAIN\par \par                 BRA.S    CallDB    ;Invoke the debugger\par                 ;standard header\par                 DC.W     $0000     ;flags\par                 DC.L     'FKEY'    ;'FKEY' is 464B4559 hex\par                 DC.W     $0008     ;FKEY Number\par                 DC.W     $0000     ;Version number\par     CallDB      DC.W     $A9FF     ;Debugger trap\par                 RTS\par                 END\par }\pard \qj\li180\ri-900 {\par }{\b InstallDBFKEY (An MPW Installation Script)\par }{\f22\fs18 \par }\pard \li180\ri-900 {\f22\fs18  #  DebugKey Installer Script\par     #\par     #  Place this file in the current directory and type\par     #  "InstallDBFKEY <Enter>" to install the debugger FKEY\par     #  in your System file.\par     #\par       Asm DebugKey.a\par       Link DebugKey.a.o -o "\{SystemFolder\}"System -rt FKEY=8\par }\pard \qj\li180\ri-900 {\par \par }{\b Further Reference:\par }{______________________________________________________________________________\par }\pard \qj\fi-360\li900\ri-900 {\bullet \tab }{\i Inside Macintosh}{, Volumes I & V, The Window Manager\par \bullet \tab }{\i Inside Macintosh}{, Volume II, The Memory Manager & The Segment Loader\par \bullet \tab }{\i Inside Macintosh}{, Volume V, The Start Manager\par \bullet \tab }{\i MPW Reference Manual\par }{\bullet \tab Technical Note #208, Setting and Restoring A5\par \bullet \tab Technical Note #240, Using MPW for Non-Macintosh 68000 Systems\par }\pard \qj\li180\ri-900 {\par }}