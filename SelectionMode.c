#include <Types.h>#include <Memory.h>#include <Quickdraw.h>#include <Events.h>#include <Menus.h>#include <Windows.h>#include <HyperXCmd.h>#include <TextUtils.h>#define QUIT_GLOBAL_NAME        "\pgSelectionModeQuit"#define RECTS_GLOBAL_NAME       "\pgSelectionModeRects"static int mystrlen(const char* str);pascal void main(XCmdPtr pp) {    WindowPtr cardWindow = NULL;    RgnHandle mouseRgn = NewRgn();    GrafPtr currentPort = NULL;    Point mousePos = {0};    Boolean mouseInsideCard = false;    Handle falseString = NULL;    Boolean keepGoing = true;    Str255 quitGlobalStr = {0};    Handle quitGlobalValue = NULL;    falseString = PasToZero(pp, "\pfalse");    SetGlobal(pp, QUIT_GLOBAL_NAME, falseString);    DisposeHandle(falseString);    GetPort(&currentPort);    GetMouse(&mousePos);    if (PtInRect(mousePos, &currentPort->portRect)) {        SendCardMessage(pp, "\ppointerEnteredCard");        mouseInsideCard = true;    }    LocalToGlobal(&mousePos);    SetRectRgn(mouseRgn, mousePos.h, mousePos.v, mousePos.h + 1, mousePos.v + 1);    cardWindow = currentPort;    while (keepGoing) {        EventRecord currentEvent = {0};        if (WaitNextEvent(everyEvent,                          &currentEvent,                          10,                          mouseRgn)) {            switch (currentEvent.what) {                case mouseDown:                case mouseUp: {                    WindowPtr foundWindow = NULL;                    WindowPartCode part = FindWindow(currentEvent.where, &foundWindow);                    switch (part) {                        case inContent:                            if (foundWindow == cardWindow) {                                if (currentEvent.what == mouseDown) {                                    SendCardMessage(pp, "\ppointerDown");                                } else {                                    SendCardMessage(pp, "\ppointerUp");                                }                            } else {                                SendHCEvent(pp, &currentEvent);                            }                            break;                        default:                            SendHCEvent(pp, &currentEvent);                    }                    break;                }                case osEvt:                    switch ((currentEvent.message >> 24) & 0x00ff) {                        case mouseMovedMessage: {                            Boolean mouseStillInsideCard = false;                            GetMouse(&mousePos);                            mouseStillInsideCard = PtInRgn(mousePos, currentPort->visRgn);                            if (mouseInsideCard && !mouseStillInsideCard) {                                SendCardMessage(pp, "\ppointerLeaveCard");                            } else if (!mouseInsideCard && mouseStillInsideCard) {                                SendCardMessage(pp, "\ppointerEnteredCard");                            }                            mouseInsideCard = mouseStillInsideCard;                            LocalToGlobal(&mousePos);                            SetRectRgn(mouseRgn, mousePos.h, mousePos.v, mousePos.h + 1, mousePos.v + 1);                            SendCardMessage(pp, "\ppointerMoved");                            if (!mouseInsideCard) {                                SendHCEvent(pp, &currentEvent);                            }                            break;                        }                        case updateEvt: {                            WindowPtr drawWindow = (WindowPtr) currentEvent.message;                            if (drawWindow == cardWindow) {                                Rect box = {0};                                Str255 rectStr = {0};                                Ptr nextItem = NULL;                                Ptr currItem = NULL;                                Handle rectsGlobalValue = NULL;                                GrafPtr oldPort = NULL;                                SendHCEvent(pp, &currentEvent);                                rectsGlobalValue = GetGlobal(pp, RECTS_GLOBAL_NAME);                                if (rectsGlobalValue && (*rectsGlobalValue)[0] != 0) {                                    currItem = *rectsGlobalValue;                                    nextItem = currItem;                                    ScanToReturn(pp, &nextItem);                                    if (nextItem == NULL) {                                        nextItem = currItem + mystrlen(currItem);                                    }                                    rectStr[0] = nextItem - currItem;                                    BlockMoveData(currItem, rectStr + 1, rectStr[0]);                                    StrToRect(pp, rectStr, &box);                                    GetPort(&oldPort);                                    SetPort(cardWindow);                                    ForeColor(redColor);                                    FrameRect(&box);                                    SetPort(oldPort);                                }                            } else {                                SendHCEvent(pp, &currentEvent);                            }                            break;                        }                        default:                            SendHCEvent(pp, &currentEvent);                            break;                    }                    break;                default:                    SendHCEvent(pp, &currentEvent);                    break;            }        }        quitGlobalValue = GetGlobal(pp, QUIT_GLOBAL_NAME);        ZeroToPas(pp, quitGlobalValue ? *quitGlobalValue : "", quitGlobalStr);        keepGoing = EqualString(quitGlobalStr, "\pfalse", false, false);    }}static int mystrlen(const char* str) {    int x = 0;    while (str[x]) {        ++x;    }    return x;}